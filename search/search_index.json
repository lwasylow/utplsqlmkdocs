{
    "docs": [
        {
            "location": "/", 
            "text": "UTPLSQLDOCS\n\n\n\n\nUT\n\n\nUT_ANNOTATION_CACHE_MANAGER\n\n\nUT_ANNOTATION_MANAGER\n\n\nUT_ANNOTATION_PARSER\n\n\nUT_ANSICONSOLE_HELPER\n\n\nUT_COMPOUND_DATA_HELPER\n\n\nUT_COVERAGE\n\n\nUT_COVERAGE_BLOCK\n\n\nUT_COVERAGE_HELPER\n\n\nUT_COVERAGE_HELPER_BLOCK\n\n\nUT_COVERAGE_HELPER_PROFILER\n\n\nUT_COVERAGE_PROFILER\n\n\nUT_COVERAGE_REPORT_HTML_HELPER\n\n\nUT_CURR_USR_COMPOUND_HELPER\n\n\nUT_EVENT_MANAGER\n\n\nUT_EXPECTATION_PROCESSOR\n\n\nUT_FILE_MAPPER\n\n\nUT_METADATA\n\n\nUT_RUNNER\n\n\nUT_SUITE_BUILDER\n\n\nUT_SUITE_MANAGER\n\n\nUT_TEAMCITY_REPORTER_HELPER\n\n\nUT_UTILS", 
            "title": "UTPLSQLDOCS"
        }, 
        {
            "location": "/#utplsqldocs", 
            "text": "UT  UT_ANNOTATION_CACHE_MANAGER  UT_ANNOTATION_MANAGER  UT_ANNOTATION_PARSER  UT_ANSICONSOLE_HELPER  UT_COMPOUND_DATA_HELPER  UT_COVERAGE  UT_COVERAGE_BLOCK  UT_COVERAGE_HELPER  UT_COVERAGE_HELPER_BLOCK  UT_COVERAGE_HELPER_PROFILER  UT_COVERAGE_PROFILER  UT_COVERAGE_REPORT_HTML_HELPER  UT_CURR_USR_COMPOUND_HELPER  UT_EVENT_MANAGER  UT_EXPECTATION_PROCESSOR  UT_FILE_MAPPER  UT_METADATA  UT_RUNNER  UT_SUITE_BUILDER  UT_SUITE_MANAGER  UT_TEAMCITY_REPORTER_HELPER  UT_UTILS", 
            "title": "UTPLSQLDOCS"
        }, 
        {
            "location": "/ut/", 
            "text": "UT\n\n\n\n\n\n\nVariables\n\n\n\n\n\n\nExceptions\n\n\n\n\n\n\nVERSION Function\n\n\n\n\nSET_NLS Procedure\n\n\nRESET_NLS Procedure\n\n\n\n\nVariables\n\n\n\n\n\n\n\n\nName\n\n\nCode\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ng_nls_date_format\n\n\ng_nls_date_format varchar2(4000);\n\n\n\n\n\n\n\n\npragma\n\n\n  pragma exception_init (e_package_invalidated, -04068);\n\n\n\n\n\n\n\n\nraise\n\n\n    raise e_package_invalidated;\n\n\n\n\n\n\n\n\nend\n\n\n  end if;\n\n\n\n\n\n\n\n\nc_fail_on_errors\n\n\n  c_fail_on_errors constant boolean := false;\n\n\n\n\n\n\n\n\nc_fail_on_errors\n\n\n  c_fail_on_errors constant boolean := false;\n\n\n\n\n\n\n\n\nl_paths\n\n\n  l_paths     ut_varchar2_list := ut_varchar2_list(sys_context('userenv', 'current_schema'));\n\n\n\n\n\n\n\n\nl_lines\n\n\n  l_lines     sys_refcursor;\n\n\n\n\n\n\n\n\nl_line\n\n\n  l_line      varchar2(4000);\n\n\n\n\n\n\n\n\nloop\n\n\n    loop\n      fetch l_lines into l_line;\n\n\n\n\n\n\n\n\nexit\n\n\n      exit when l_lines%notfound;\n\n\n\n\n\n\n\n\npipe\n\n\n      pipe row(l_line);\n\n\n\n\n\n\n\n\nend\n\n\n    end loop;\n\n\n\n\n\n\n\n\nclose\n\n\n    close l_lines;\n\n\n\n\n\n\n\n\nend\n\n\n  end if;\n\n\n\n\n\n\n\n\nl_paths\n\n\n  l_paths     ut_varchar2_list := ut_varchar2_list(sys_context('userenv', 'current_schema'));\n\n\n\n\n\n\n\n\nl_lines\n\n\n  l_lines     sys_refcursor;\n\n\n\n\n\n\n\n\nl_line\n\n\n  l_line      varchar2(4000);\n\n\n\n\n\n\n\n\nloop\n\n\n    loop\n      fetch l_lines into l_line;\n\n\n\n\n\n\n\n\nexit\n\n\n      exit when l_lines%notfound;\n\n\n\n\n\n\n\n\npipe\n\n\n      pipe row(l_line);\n\n\n\n\n\n\n\n\nend\n\n\n    end loop;\n\n\n\n\n\n\n\n\nclose\n\n\n    close l_lines;\n\n\n\n\n\n\n\n\nend\n\n\n  end if;\n\n\n\n\n\n\n\n\nl_lines\n\n\n  l_lines     sys_refcursor;\n\n\n\n\n\n\n\n\nl_line\n\n\n  l_line      varchar2(4000);\n\n\n\n\n\n\n\n\nloop\n\n\n    loop\n      fetch l_lines into l_line;\n\n\n\n\n\n\n\n\nexit\n\n\n      exit when l_lines%notfound;\n\n\n\n\n\n\n\n\npipe\n\n\n      pipe row(l_line);\n\n\n\n\n\n\n\n\nend\n\n\n    end loop;\n\n\n\n\n\n\n\n\nclose\n\n\n    close l_lines;\n\n\n\n\n\n\n\n\nend\n\n\n  end if;\n\n\n\n\n\n\n\n\nl_lines\n\n\n  l_lines     sys_refcursor;\n\n\n\n\n\n\n\n\nl_line\n\n\n  l_line      varchar2(4000);\n\n\n\n\n\n\n\n\nloop\n\n\n    loop\n      fetch l_lines into l_line;\n\n\n\n\n\n\n\n\nexit\n\n\n      exit when l_lines%notfound;\n\n\n\n\n\n\n\n\npipe\n\n\n      pipe row(l_line);\n\n\n\n\n\n\n\n\nend\n\n\n    end loop;\n\n\n\n\n\n\n\n\nclose\n\n\n    close l_lines;\n\n\n\n\n\n\n\n\nend\n\n\n  end if;\n\n\n\n\n\n\n\n\nl_paths\n\n\n  l_paths     ut_varchar2_list := ut_varchar2_list(coalesce(a_path, sys_context('userenv', 'current_schema')));\n\n\n\n\n\n\n\n\nl_lines\n\n\n  l_lines     sys_refcursor;\n\n\n\n\n\n\n\n\nl_line\n\n\n  l_line      varchar2(4000);\n\n\n\n\n\n\n\n\nloop\n\n\n    loop\n      fetch l_lines into l_line;\n\n\n\n\n\n\n\n\nexit\n\n\n      exit when l_lines%notfound;\n\n\n\n\n\n\n\n\npipe\n\n\n      pipe row(l_line);\n\n\n\n\n\n\n\n\nend\n\n\n    end loop;\n\n\n\n\n\n\n\n\nclose\n\n\n    close l_lines;\n\n\n\n\n\n\n\n\nend\n\n\n  end if;\n\n\n\n\n\n\n\n\nl_paths\n\n\n  l_paths     ut_varchar2_list := ut_varchar2_list(coalesce(a_path, sys_context('userenv', 'current_schema')));\n\n\n\n\n\n\n\n\nl_lines\n\n\n  l_lines     sys_refcursor;\n\n\n\n\n\n\n\n\nl_line\n\n\n  l_line      varchar2(4000);\n\n\n\n\n\n\n\n\nloop\n\n\n    loop\n      fetch l_lines into l_line;\n\n\n\n\n\n\n\n\nexit\n\n\n      exit when l_lines%notfound;\n\n\n\n\n\n\n\n\npipe\n\n\n      pipe row(l_line);\n\n\n\n\n\n\n\n\nend\n\n\n    end loop;\n\n\n\n\n\n\n\n\nclose\n\n\n    close l_lines;\n\n\n\n\n\n\n\n\nend\n\n\n  end if;\n\n\n\n\n\n\n\n\nend\n\n\n  end if;\n\n\n\n\n\n\n\n\nend\n\n\n  end if;\n\n\n\n\n\n\n\n\nend\n\n\n  end if;\n\n\n\n\n\n\n\n\nexecute\n\n\n  execute immediate 'alter session set nls_date_format = '''\n\n\n\n\n\n\n\n\nend\n\n\n  end if;\n\n\n\n\n\n\n\n\n\n\n  g_nls_date_format := null;\n\n\n\n\n\n\n\n\nend\n\n\nend ut;\n\n\n\n\n\n\n\n\n\n\nExceptions\n\n\n\n\n\n\n\n\nName\n\n\nCode\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ng_nls_date_format\n\n\ng_nls_date_format varchar2(4000);\n\n\n\n\n\n\n\n\npragma\n\n\n  pragma exception_init (e_package_invalidated, -04068);\n\n\n\n\n\n\n\n\nraise\n\n\n    raise e_package_invalidated;\n\n\n\n\n\n\n\n\nend\n\n\n  end if;\n\n\n\n\n\n\n\n\nc_fail_on_errors\n\n\n  c_fail_on_errors constant boolean := false;\n\n\n\n\n\n\n\n\nc_fail_on_errors\n\n\n  c_fail_on_errors constant boolean := false;\n\n\n\n\n\n\n\n\nl_paths\n\n\n  l_paths     ut_varchar2_list := ut_varchar2_list(sys_context('userenv', 'current_schema'));\n\n\n\n\n\n\n\n\nl_lines\n\n\n  l_lines     sys_refcursor;\n\n\n\n\n\n\n\n\nl_line\n\n\n  l_line      varchar2(4000);\n\n\n\n\n\n\n\n\nloop\n\n\n    loop\n      fetch l_lines into l_line;\n\n\n\n\n\n\n\n\nexit\n\n\n      exit when l_lines%notfound;\n\n\n\n\n\n\n\n\npipe\n\n\n      pipe row(l_line);\n\n\n\n\n\n\n\n\nend\n\n\n    end loop;\n\n\n\n\n\n\n\n\nclose\n\n\n    close l_lines;\n\n\n\n\n\n\n\n\nend\n\n\n  end if;\n\n\n\n\n\n\n\n\nl_paths\n\n\n  l_paths     ut_varchar2_list := ut_varchar2_list(sys_context('userenv', 'current_schema'));\n\n\n\n\n\n\n\n\nl_lines\n\n\n  l_lines     sys_refcursor;\n\n\n\n\n\n\n\n\nl_line\n\n\n  l_line      varchar2(4000);\n\n\n\n\n\n\n\n\nloop\n\n\n    loop\n      fetch l_lines into l_line;\n\n\n\n\n\n\n\n\nexit\n\n\n      exit when l_lines%notfound;\n\n\n\n\n\n\n\n\npipe\n\n\n      pipe row(l_line);\n\n\n\n\n\n\n\n\nend\n\n\n    end loop;\n\n\n\n\n\n\n\n\nclose\n\n\n    close l_lines;\n\n\n\n\n\n\n\n\nend\n\n\n  end if;\n\n\n\n\n\n\n\n\nl_lines\n\n\n  l_lines     sys_refcursor;\n\n\n\n\n\n\n\n\nl_line\n\n\n  l_line      varchar2(4000);\n\n\n\n\n\n\n\n\nloop\n\n\n    loop\n      fetch l_lines into l_line;\n\n\n\n\n\n\n\n\nexit\n\n\n      exit when l_lines%notfound;\n\n\n\n\n\n\n\n\npipe\n\n\n      pipe row(l_line);\n\n\n\n\n\n\n\n\nend\n\n\n    end loop;\n\n\n\n\n\n\n\n\nclose\n\n\n    close l_lines;\n\n\n\n\n\n\n\n\nend\n\n\n  end if;\n\n\n\n\n\n\n\n\nl_lines\n\n\n  l_lines     sys_refcursor;\n\n\n\n\n\n\n\n\nl_line\n\n\n  l_line      varchar2(4000);\n\n\n\n\n\n\n\n\nloop\n\n\n    loop\n      fetch l_lines into l_line;\n\n\n\n\n\n\n\n\nexit\n\n\n      exit when l_lines%notfound;\n\n\n\n\n\n\n\n\npipe\n\n\n      pipe row(l_line);\n\n\n\n\n\n\n\n\nend\n\n\n    end loop;\n\n\n\n\n\n\n\n\nclose\n\n\n    close l_lines;\n\n\n\n\n\n\n\n\nend\n\n\n  end if;\n\n\n\n\n\n\n\n\nl_paths\n\n\n  l_paths     ut_varchar2_list := ut_varchar2_list(coalesce(a_path, sys_context('userenv', 'current_schema')));\n\n\n\n\n\n\n\n\nl_lines\n\n\n  l_lines     sys_refcursor;\n\n\n\n\n\n\n\n\nl_line\n\n\n  l_line      varchar2(4000);\n\n\n\n\n\n\n\n\nloop\n\n\n    loop\n      fetch l_lines into l_line;\n\n\n\n\n\n\n\n\nexit\n\n\n      exit when l_lines%notfound;\n\n\n\n\n\n\n\n\npipe\n\n\n      pipe row(l_line);\n\n\n\n\n\n\n\n\nend\n\n\n    end loop;\n\n\n\n\n\n\n\n\nclose\n\n\n    close l_lines;\n\n\n\n\n\n\n\n\nend\n\n\n  end if;\n\n\n\n\n\n\n\n\nl_paths\n\n\n  l_paths     ut_varchar2_list := ut_varchar2_list(coalesce(a_path, sys_context('userenv', 'current_schema')));\n\n\n\n\n\n\n\n\nl_lines\n\n\n  l_lines     sys_refcursor;\n\n\n\n\n\n\n\n\nl_line\n\n\n  l_line      varchar2(4000);\n\n\n\n\n\n\n\n\nloop\n\n\n    loop\n      fetch l_lines into l_line;\n\n\n\n\n\n\n\n\nexit\n\n\n      exit when l_lines%notfound;\n\n\n\n\n\n\n\n\npipe\n\n\n      pipe row(l_line);\n\n\n\n\n\n\n\n\nend\n\n\n    end loop;\n\n\n\n\n\n\n\n\nclose\n\n\n    close l_lines;\n\n\n\n\n\n\n\n\nend\n\n\n  end if;\n\n\n\n\n\n\n\n\nend\n\n\n  end if;\n\n\n\n\n\n\n\n\nend\n\n\n  end if;\n\n\n\n\n\n\n\n\nend\n\n\n  end if;\n\n\n\n\n\n\n\n\nexecute\n\n\n  execute immediate 'alter session set nls_date_format = '''\n\n\n\n\n\n\n\n\nend\n\n\n  end if;\n\n\n\n\n\n\n\n\n\n\n  g_nls_date_format := null;\n\n\n\n\n\n\n\n\nend\n\n\nend ut;\n\n\n\n\n\n\n\n\n\n\nVERSION Function\n\n\n\n\nutPLSQL - Version 3\n  Copyright 2016 - 2017 utPLSQL Project\n  Licensed under the Apache License, Version 2.0 (the \nLicense\n):\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n  http://www.apache.org/licenses/LICENSE-2.0\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \nAS IS\n BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n\n\n\n\n\nSyntax\n\n\nfunction version return varchar2\n\n\n\n\nSET_NLS Procedure\n\n\n\n\nHelper procedure to set NLS session parameter for date processing in refcursor.\nIt needs to be called before refcursor is open in order to have DATE data type data in refcursor\n properly transformed into XML format as a date-time element.\nIf the function is not called before opening a cursor to be compared, the DATE data is compared using default NLS setting for date.\n\n\n\n\n\nSyntax\n\n\nprocedure set_nls\n\n\n\n\nRESET_NLS Procedure\n\n\n\n\nHelper procedure to reset NLS session parameter to it\ns original state.\nIt needs to be called after refcursor is open in order restore the original session state and keep the NLS date setting at default.\n\n\n\n\n\nSyntax\n\n\nprocedure reset_nls", 
            "title": "UT"
        }, 
        {
            "location": "/ut/#ut", 
            "text": "Variables    Exceptions    VERSION Function   SET_NLS Procedure  RESET_NLS Procedure", 
            "title": "UT"
        }, 
        {
            "location": "/ut/#variables", 
            "text": "Name  Code  Description      g_nls_date_format  g_nls_date_format varchar2(4000);     pragma    pragma exception_init (e_package_invalidated, -04068);     raise      raise e_package_invalidated;     end    end if;     c_fail_on_errors    c_fail_on_errors constant boolean := false;     c_fail_on_errors    c_fail_on_errors constant boolean := false;     l_paths    l_paths     ut_varchar2_list := ut_varchar2_list(sys_context('userenv', 'current_schema'));     l_lines    l_lines     sys_refcursor;     l_line    l_line      varchar2(4000);     loop      loop       fetch l_lines into l_line;     exit        exit when l_lines%notfound;     pipe        pipe row(l_line);     end      end loop;     close      close l_lines;     end    end if;     l_paths    l_paths     ut_varchar2_list := ut_varchar2_list(sys_context('userenv', 'current_schema'));     l_lines    l_lines     sys_refcursor;     l_line    l_line      varchar2(4000);     loop      loop       fetch l_lines into l_line;     exit        exit when l_lines%notfound;     pipe        pipe row(l_line);     end      end loop;     close      close l_lines;     end    end if;     l_lines    l_lines     sys_refcursor;     l_line    l_line      varchar2(4000);     loop      loop       fetch l_lines into l_line;     exit        exit when l_lines%notfound;     pipe        pipe row(l_line);     end      end loop;     close      close l_lines;     end    end if;     l_lines    l_lines     sys_refcursor;     l_line    l_line      varchar2(4000);     loop      loop       fetch l_lines into l_line;     exit        exit when l_lines%notfound;     pipe        pipe row(l_line);     end      end loop;     close      close l_lines;     end    end if;     l_paths    l_paths     ut_varchar2_list := ut_varchar2_list(coalesce(a_path, sys_context('userenv', 'current_schema')));     l_lines    l_lines     sys_refcursor;     l_line    l_line      varchar2(4000);     loop      loop       fetch l_lines into l_line;     exit        exit when l_lines%notfound;     pipe        pipe row(l_line);     end      end loop;     close      close l_lines;     end    end if;     l_paths    l_paths     ut_varchar2_list := ut_varchar2_list(coalesce(a_path, sys_context('userenv', 'current_schema')));     l_lines    l_lines     sys_refcursor;     l_line    l_line      varchar2(4000);     loop      loop       fetch l_lines into l_line;     exit        exit when l_lines%notfound;     pipe        pipe row(l_line);     end      end loop;     close      close l_lines;     end    end if;     end    end if;     end    end if;     end    end if;     execute    execute immediate 'alter session set nls_date_format = '''     end    end if;        g_nls_date_format := null;     end  end ut;", 
            "title": "Variables"
        }, 
        {
            "location": "/ut/#exceptions", 
            "text": "Name  Code  Description      g_nls_date_format  g_nls_date_format varchar2(4000);     pragma    pragma exception_init (e_package_invalidated, -04068);     raise      raise e_package_invalidated;     end    end if;     c_fail_on_errors    c_fail_on_errors constant boolean := false;     c_fail_on_errors    c_fail_on_errors constant boolean := false;     l_paths    l_paths     ut_varchar2_list := ut_varchar2_list(sys_context('userenv', 'current_schema'));     l_lines    l_lines     sys_refcursor;     l_line    l_line      varchar2(4000);     loop      loop       fetch l_lines into l_line;     exit        exit when l_lines%notfound;     pipe        pipe row(l_line);     end      end loop;     close      close l_lines;     end    end if;     l_paths    l_paths     ut_varchar2_list := ut_varchar2_list(sys_context('userenv', 'current_schema'));     l_lines    l_lines     sys_refcursor;     l_line    l_line      varchar2(4000);     loop      loop       fetch l_lines into l_line;     exit        exit when l_lines%notfound;     pipe        pipe row(l_line);     end      end loop;     close      close l_lines;     end    end if;     l_lines    l_lines     sys_refcursor;     l_line    l_line      varchar2(4000);     loop      loop       fetch l_lines into l_line;     exit        exit when l_lines%notfound;     pipe        pipe row(l_line);     end      end loop;     close      close l_lines;     end    end if;     l_lines    l_lines     sys_refcursor;     l_line    l_line      varchar2(4000);     loop      loop       fetch l_lines into l_line;     exit        exit when l_lines%notfound;     pipe        pipe row(l_line);     end      end loop;     close      close l_lines;     end    end if;     l_paths    l_paths     ut_varchar2_list := ut_varchar2_list(coalesce(a_path, sys_context('userenv', 'current_schema')));     l_lines    l_lines     sys_refcursor;     l_line    l_line      varchar2(4000);     loop      loop       fetch l_lines into l_line;     exit        exit when l_lines%notfound;     pipe        pipe row(l_line);     end      end loop;     close      close l_lines;     end    end if;     l_paths    l_paths     ut_varchar2_list := ut_varchar2_list(coalesce(a_path, sys_context('userenv', 'current_schema')));     l_lines    l_lines     sys_refcursor;     l_line    l_line      varchar2(4000);     loop      loop       fetch l_lines into l_line;     exit        exit when l_lines%notfound;     pipe        pipe row(l_line);     end      end loop;     close      close l_lines;     end    end if;     end    end if;     end    end if;     end    end if;     execute    execute immediate 'alter session set nls_date_format = '''     end    end if;        g_nls_date_format := null;     end  end ut;", 
            "title": "Exceptions"
        }, 
        {
            "location": "/ut/#version-function", 
            "text": "utPLSQL - Version 3   Copyright 2016 - 2017 utPLSQL Project   Licensed under the Apache License, Version 2.0 (the  License ):   you may not use this file except in compliance with the License.   You may obtain a copy of the License at   http://www.apache.org/licenses/LICENSE-2.0   Unless required by applicable law or agreed to in writing, software   distributed under the License is distributed on an  AS IS  BASIS,   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   See the License for the specific language governing permissions and   limitations under the License.", 
            "title": "VERSION Function"
        }, 
        {
            "location": "/ut/#syntax", 
            "text": "function version return varchar2", 
            "title": "Syntax"
        }, 
        {
            "location": "/ut/#set_nls-procedure", 
            "text": "Helper procedure to set NLS session parameter for date processing in refcursor. It needs to be called before refcursor is open in order to have DATE data type data in refcursor  properly transformed into XML format as a date-time element. If the function is not called before opening a cursor to be compared, the DATE data is compared using default NLS setting for date.", 
            "title": "SET_NLS Procedure"
        }, 
        {
            "location": "/ut/#syntax_1", 
            "text": "procedure set_nls", 
            "title": "Syntax"
        }, 
        {
            "location": "/ut/#reset_nls-procedure", 
            "text": "Helper procedure to reset NLS session parameter to it s original state. It needs to be called after refcursor is open in order restore the original session state and keep the NLS date setting at default.", 
            "title": "RESET_NLS Procedure"
        }, 
        {
            "location": "/ut/#syntax_2", 
            "text": "procedure reset_nls", 
            "title": "Syntax"
        }, 
        {
            "location": "/ut_annotation_cache_manager/", 
            "text": "UT_ANNOTATION_CACHE_MANAGER\n\n\n\n\nUPDATE_CACHE Procedure\n\n\nGET_ANNOTATIONS_FOR_OBJECTS Function\n\n\nCLEANUP_CACHE Procedure\n\n\nPURGE_CACHE Procedure\n\n\n\n\nUPDATE_CACHE Procedure\n\n\n\n\nutPLSQL - Version 3\n  Copyright 2016 - 2017 utPLSQL Project\n  Licensed under the Apache License, Version 2.0 (the \nLicense\n):\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n  http://www.apache.org/licenses/LICENSE-2.0\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \nAS IS\n BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n\n\n\n\n\nSyntax\n\n\nprocedure update_cache(a_object ut_annotated_object)\n\n\n\n\nGET_ANNOTATIONS_FOR_OBJECTS Function\n\n\n\n\nReturns a ref_cursor containing \nut_annotated_object\n as result\nRange of data returned is limited by the input collection o cache object info\n\n\n\n\n\nSyntax\n\n\nfunction get_annotations_for_objects(a_cached_objects ut_annotation_objs_cache_info) return sys_refcursor\n\n\n\n\nParameters\n\n\n\n\n\n\n\n\nName\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\na_cached_objects\n\n\na \nut_annotation_objs_cache_info\n list with information about objects to get from cache\n\n\n\n\n\n\n\n\nCLEANUP_CACHE Procedure\n\n\n\n\nRemoves cached information about annotations for objects on the list and updates parse_time in cache info table.\n\n\n\n\n\nSyntax\n\n\nprocedure cleanup_cache(a_objects ut_annotation_objs_cache_info)\n\n\n\n\nParameters\n\n\n\n\n\n\n\n\nName\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\na_objects\n\n\na \nut_annotation_objs_cache_info\n list with information about objects to remove from cache\n\n\n\n\n\n\n\n\nPURGE_CACHE Procedure\n\n\n\n\nRemoves cached information about annotations for objects of specified type and specified owner\n\n\n\n\n\nSyntax\n\n\nprocedure purge_cache(a_object_owner varchar2, a_object_type varchar2)\n\n\n\n\nParameters\n\n\n\n\n\n\n\n\nName\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\na_object_owner\n\n\nowner of objects to purge annotations for\n\n\n\n\n\n\na_object_type\n\n\ntype of objects to purge annotations for", 
            "title": "UT_ANNOTATION_CACHE_MANAGER"
        }, 
        {
            "location": "/ut_annotation_cache_manager/#ut_annotation_cache_manager", 
            "text": "UPDATE_CACHE Procedure  GET_ANNOTATIONS_FOR_OBJECTS Function  CLEANUP_CACHE Procedure  PURGE_CACHE Procedure", 
            "title": "UT_ANNOTATION_CACHE_MANAGER"
        }, 
        {
            "location": "/ut_annotation_cache_manager/#update_cache-procedure", 
            "text": "utPLSQL - Version 3   Copyright 2016 - 2017 utPLSQL Project   Licensed under the Apache License, Version 2.0 (the  License ):   you may not use this file except in compliance with the License.   You may obtain a copy of the License at   http://www.apache.org/licenses/LICENSE-2.0   Unless required by applicable law or agreed to in writing, software   distributed under the License is distributed on an  AS IS  BASIS,   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   See the License for the specific language governing permissions and   limitations under the License.", 
            "title": "UPDATE_CACHE Procedure"
        }, 
        {
            "location": "/ut_annotation_cache_manager/#syntax", 
            "text": "procedure update_cache(a_object ut_annotated_object)", 
            "title": "Syntax"
        }, 
        {
            "location": "/ut_annotation_cache_manager/#get_annotations_for_objects-function", 
            "text": "Returns a ref_cursor containing  ut_annotated_object  as result Range of data returned is limited by the input collection o cache object info", 
            "title": "GET_ANNOTATIONS_FOR_OBJECTS Function"
        }, 
        {
            "location": "/ut_annotation_cache_manager/#syntax_1", 
            "text": "function get_annotations_for_objects(a_cached_objects ut_annotation_objs_cache_info) return sys_refcursor", 
            "title": "Syntax"
        }, 
        {
            "location": "/ut_annotation_cache_manager/#parameters", 
            "text": "Name  Description      a_cached_objects  a  ut_annotation_objs_cache_info  list with information about objects to get from cache", 
            "title": "Parameters"
        }, 
        {
            "location": "/ut_annotation_cache_manager/#cleanup_cache-procedure", 
            "text": "Removes cached information about annotations for objects on the list and updates parse_time in cache info table.", 
            "title": "CLEANUP_CACHE Procedure"
        }, 
        {
            "location": "/ut_annotation_cache_manager/#syntax_2", 
            "text": "procedure cleanup_cache(a_objects ut_annotation_objs_cache_info)", 
            "title": "Syntax"
        }, 
        {
            "location": "/ut_annotation_cache_manager/#parameters_1", 
            "text": "Name  Description      a_objects  a  ut_annotation_objs_cache_info  list with information about objects to remove from cache", 
            "title": "Parameters"
        }, 
        {
            "location": "/ut_annotation_cache_manager/#purge_cache-procedure", 
            "text": "Removes cached information about annotations for objects of specified type and specified owner", 
            "title": "PURGE_CACHE Procedure"
        }, 
        {
            "location": "/ut_annotation_cache_manager/#syntax_3", 
            "text": "procedure purge_cache(a_object_owner varchar2, a_object_type varchar2)", 
            "title": "Syntax"
        }, 
        {
            "location": "/ut_annotation_cache_manager/#parameters_2", 
            "text": "Name  Description      a_object_owner  owner of objects to purge annotations for    a_object_type  type of objects to purge annotations for", 
            "title": "Parameters"
        }, 
        {
            "location": "/ut_annotation_manager/", 
            "text": "UT_ANNOTATION_MANAGER\n\n\n\n\nGET_ANNOTATED_OBJECTS Function\n\n\nREBUILD_ANNOTATION_CACHE Procedure\n\n\nPURGE_CACHE Procedure\n\n\n\n\nGET_ANNOTATED_OBJECTS Function\n\n\n\n\nGets annotations for all objects of a specified type for database schema.\nAnnotations that are stale or missing are parsed and placed in persistent cache.\nAfter placing in cache, annotation data is returned as pipelined table data.\n\n\n\n\n\nSyntax\n\n\nfunction get_annotated_objects(a_object_owner varchar2, a_object_type varchar2) return ut_annotated_objects pipelined\n\n\n\n\nParameters\n\n\n\n\n\n\n\n\nName\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\na_object_owner\n\n\nowner of objects to get annotations for\n\n\n\n\n\n\na_object_type\n\n\ntype of objects to get annotations for\n\n\n\n\n\n\nreturn\n\n\narray containing annotated objects along with annotations for each object (nested)\n\n\n\n\n\n\n\n\nREBUILD_ANNOTATION_CACHE Procedure\n\n\n\n\nRebuilds annotation cache for a specified schema and object type.\n The procedure is called internally by \nget_annotated_objects\n function.\n It can be used to speedup initial execution of utPLSQL on a given schema\n  if it is executed before any call is made to \nut.run\n or \nut_runner.run\n procedure.\n\n\n\n\n\nSyntax\n\n\nprocedure rebuild_annotation_cache(a_object_owner varchar2, a_object_type varchar2)\n\n\n\n\nParameters\n\n\n\n\n\n\n\n\nName\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\na_object_owner\n\n\nowner of objects to get annotations for\n\n\n\n\n\n\na_object_type\n\n\ntype of objects to get annotations for\n\n\n\n\n\n\n\n\nPURGE_CACHE Procedure\n\n\n\n\nRemoves cached information about annotations for objects of specified type and specified owner\n\n\n\n\n\nSyntax\n\n\nprocedure purge_cache(a_object_owner varchar2, a_object_type varchar2)\n\n\n\n\nParameters\n\n\n\n\n\n\n\n\nName\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\na_object_owner\n\n\nowner of objects to purge annotations for\n\n\n\n\n\n\na_object_type\n\n\ntype of objects to purge annotations for", 
            "title": "UT_ANNOTATION_MANAGER"
        }, 
        {
            "location": "/ut_annotation_manager/#ut_annotation_manager", 
            "text": "GET_ANNOTATED_OBJECTS Function  REBUILD_ANNOTATION_CACHE Procedure  PURGE_CACHE Procedure", 
            "title": "UT_ANNOTATION_MANAGER"
        }, 
        {
            "location": "/ut_annotation_manager/#get_annotated_objects-function", 
            "text": "Gets annotations for all objects of a specified type for database schema. Annotations that are stale or missing are parsed and placed in persistent cache. After placing in cache, annotation data is returned as pipelined table data.", 
            "title": "GET_ANNOTATED_OBJECTS Function"
        }, 
        {
            "location": "/ut_annotation_manager/#syntax", 
            "text": "function get_annotated_objects(a_object_owner varchar2, a_object_type varchar2) return ut_annotated_objects pipelined", 
            "title": "Syntax"
        }, 
        {
            "location": "/ut_annotation_manager/#parameters", 
            "text": "Name  Description      a_object_owner  owner of objects to get annotations for    a_object_type  type of objects to get annotations for    return  array containing annotated objects along with annotations for each object (nested)", 
            "title": "Parameters"
        }, 
        {
            "location": "/ut_annotation_manager/#rebuild_annotation_cache-procedure", 
            "text": "Rebuilds annotation cache for a specified schema and object type.  The procedure is called internally by  get_annotated_objects  function.  It can be used to speedup initial execution of utPLSQL on a given schema   if it is executed before any call is made to  ut.run  or  ut_runner.run  procedure.", 
            "title": "REBUILD_ANNOTATION_CACHE Procedure"
        }, 
        {
            "location": "/ut_annotation_manager/#syntax_1", 
            "text": "procedure rebuild_annotation_cache(a_object_owner varchar2, a_object_type varchar2)", 
            "title": "Syntax"
        }, 
        {
            "location": "/ut_annotation_manager/#parameters_1", 
            "text": "Name  Description      a_object_owner  owner of objects to get annotations for    a_object_type  type of objects to get annotations for", 
            "title": "Parameters"
        }, 
        {
            "location": "/ut_annotation_manager/#purge_cache-procedure", 
            "text": "Removes cached information about annotations for objects of specified type and specified owner", 
            "title": "PURGE_CACHE Procedure"
        }, 
        {
            "location": "/ut_annotation_manager/#syntax_2", 
            "text": "procedure purge_cache(a_object_owner varchar2, a_object_type varchar2)", 
            "title": "Syntax"
        }, 
        {
            "location": "/ut_annotation_manager/#parameters_2", 
            "text": "Name  Description      a_object_owner  owner of objects to purge annotations for    a_object_type  type of objects to purge annotations for", 
            "title": "Parameters"
        }, 
        {
            "location": "/ut_annotation_parser/", 
            "text": "UT_ANNOTATION_PARSER\n\n\n\n\nPARSE_OBJECT_ANNOTATIONS Function\n\n\nPARSE_OBJECT_ANNOTATIONS-1 Function\n\n\n\n\nPARSE_OBJECT_ANNOTATIONS Function\n\n\n\n\nRuns the source lines through dbms_preprocessor to remove lines that were not compiled (conditional compilation)\nParses the processed source code and converts it to annotations\n\n\n\n\n\nSyntax\n\n\nfunction parse_object_annotations(a_source_lines dbms_preprocessor.source_lines_t) return ut_annotations\n\n\n\n\nParameters\n\n\n\n\n\n\n\n\nName\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\na_source_lines\n\n\nordered lines of source code to be parsed\n\n\n\n\n\n\nreturn\n\n\narray containing annotations", 
            "title": "UT_ANNOTATION_PARSER"
        }, 
        {
            "location": "/ut_annotation_parser/#ut_annotation_parser", 
            "text": "PARSE_OBJECT_ANNOTATIONS Function  PARSE_OBJECT_ANNOTATIONS-1 Function", 
            "title": "UT_ANNOTATION_PARSER"
        }, 
        {
            "location": "/ut_annotation_parser/#parse_object_annotations-function", 
            "text": "Runs the source lines through dbms_preprocessor to remove lines that were not compiled (conditional compilation) Parses the processed source code and converts it to annotations", 
            "title": "PARSE_OBJECT_ANNOTATIONS Function"
        }, 
        {
            "location": "/ut_annotation_parser/#syntax", 
            "text": "function parse_object_annotations(a_source_lines dbms_preprocessor.source_lines_t) return ut_annotations", 
            "title": "Syntax"
        }, 
        {
            "location": "/ut_annotation_parser/#parameters", 
            "text": "Name  Description      a_source_lines  ordered lines of source code to be parsed    return  array containing annotations", 
            "title": "Parameters"
        }, 
        {
            "location": "/ut_ansiconsole_helper/", 
            "text": "UT_ANSICONSOLE_HELPER\n\n\n\n\n\n\nConstants\n\n\n\n\n\n\nCOLOR_ENABLED Procedure\n\n\n\n\n\n\nConstants\n\n\n\n\n\n\n\n\nName\n\n\nCode\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ngc_red\n\n\ngc_red     constant varchar2(7) := chr(27)\n\n\n\n\n\n\n\n\ngc_green\n\n\ngc_green   constant varchar2(7) := chr(27)\n\n\n\n\n\n\n\n\ngc_yellow\n\n\ngc_yellow  constant varchar2(7) := chr(27)\n\n\n\n\n\n\n\n\ngc_blue\n\n\ngc_blue    constant varchar2(7) := chr(27)\n\n\n\n\n\n\n\n\ngc_magenta\n\n\ngc_magenta constant varchar2(7) := chr(27)\n\n\n\n\n\n\n\n\ngc_cyan\n\n\ngc_cyan    constant varchar2(7) := chr(27)\n\n\n\n\n\n\n\n\ngc_reset\n\n\ngc_reset   constant varchar2(7) := chr(27)\n\n\n\n\n\n\n\n\n\n\nCOLOR_ENABLED Procedure\n\n\n\n\nutPLSQL - Version 3\n  Copyright 2016 - 2017 utPLSQL Project\n  Licensed under the Apache License, Version 2.0 (the \nLicense\n):\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n  http://www.apache.org/licenses/LICENSE-2.0\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \nAS IS\n BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n\n\n\n\n\nSyntax\n\n\nprocedure color_enabled(a_enabled boolean)", 
            "title": "UT_ANSICONSOLE_HELPER"
        }, 
        {
            "location": "/ut_ansiconsole_helper/#ut_ansiconsole_helper", 
            "text": "Constants    COLOR_ENABLED Procedure", 
            "title": "UT_ANSICONSOLE_HELPER"
        }, 
        {
            "location": "/ut_ansiconsole_helper/#constants", 
            "text": "Name  Code  Description      gc_red  gc_red     constant varchar2(7) := chr(27)     gc_green  gc_green   constant varchar2(7) := chr(27)     gc_yellow  gc_yellow  constant varchar2(7) := chr(27)     gc_blue  gc_blue    constant varchar2(7) := chr(27)     gc_magenta  gc_magenta constant varchar2(7) := chr(27)     gc_cyan  gc_cyan    constant varchar2(7) := chr(27)     gc_reset  gc_reset   constant varchar2(7) := chr(27)", 
            "title": "Constants"
        }, 
        {
            "location": "/ut_ansiconsole_helper/#color_enabled-procedure", 
            "text": "utPLSQL - Version 3   Copyright 2016 - 2017 utPLSQL Project   Licensed under the Apache License, Version 2.0 (the  License ):   you may not use this file except in compliance with the License.   You may obtain a copy of the License at   http://www.apache.org/licenses/LICENSE-2.0   Unless required by applicable law or agreed to in writing, software   distributed under the License is distributed on an  AS IS  BASIS,   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   See the License for the specific language governing permissions and   limitations under the License.", 
            "title": "COLOR_ENABLED Procedure"
        }, 
        {
            "location": "/ut_ansiconsole_helper/#syntax", 
            "text": "procedure color_enabled(a_enabled boolean)", 
            "title": "Syntax"
        }, 
        {
            "location": "/ut_compound_data_helper/", 
            "text": "UT_COMPOUND_DATA_HELPER\n\n\n\n\n\n\nConstants\n\n\n\n\n\n\nVariables\n\n\n\n\n\n\nExceptions\n\n\n\n\n\n\nGET_COLUMNS_ROW_FILTER Function\n\n\n\n\n\n\nVariables\n\n\n\n\n\n\n\n\nName\n\n\nCode\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ng_user_defined_type\n\n\ng_user_defined_type pls_integer := dbms_sql.user_defined_type;\n\n\n\n\n\n\n\n\nl_res\n\n\n  l_res xmltype;\n\n\n\n\n\n\n\n\nl_data\n\n\n  l_data ut_data_value := a_column_details.value;\n\n\n\n\n\n\n\n\nl_key\n\n\n  l_key varchar2(4000) := ut_utils.xmlgen_escaped_string(a_column_details.KEY);\n\n\n\n\n\n\n\n\nbegin\n\n\nbegin\n  l_result := '\n'\n\n\n\n\n\n\n\n\nelse\n\n\n  else\n    l_result := l_result\n\n\n\n\n\n\n\n\nend\n\n\n  end if;\n\n\n\n\n\n\n\n\n\n\n  \n  l_result := l_result\n\n\n\n\n\n\n\n\nreturn\n\n\n  \n  return xmltype(l_result);\n\n\n\n\n\n\n\n\nl_source_column\n\n\n  l_source_column varchar2(500) := a_table_alias\n\n\n\n\n\n\n\n\nend\n\n\n  end if;\n\n\n\n\n\n\n\n\nreturn\n\n\n  return l_filter;\n\n\n\n\n\n\n\n\n\n\nConstants\n\n\n\n\n\n\n\n\nName\n\n\nCode\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ngc_compare_join_by\n\n\ngc_compare_join_by   constant varchar2(10):='join_by';\n\n\n\n\n\n\n\n\ngc_compare_unordered\n\n\ngc_compare_unordered constant varchar2(10):='unordered';\n\n\n\n\n\n\n\n\ngc_compare_normal\n\n\ngc_compare_normal    constant varchar2(10):='normal';\n\n\n\n\n\n\n\n\n\n\nExceptions\n\n\n\n\n\n\n\n\nName\n\n\nCode\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ng_user_defined_type\n\n\ng_user_defined_type pls_integer := dbms_sql.user_defined_type;\n\n\n\n\n\n\n\n\nl_res\n\n\n  l_res xmltype;\n\n\n\n\n\n\n\n\nl_data\n\n\n  l_data ut_data_value := a_column_details.value;\n\n\n\n\n\n\n\n\nl_key\n\n\n  l_key varchar2(4000) := ut_utils.xmlgen_escaped_string(a_column_details.KEY);\n\n\n\n\n\n\n\n\nbegin\n\n\nbegin\n  l_result := '\n'\n\n\n\n\n\n\n\n\nelse\n\n\n  else\n    l_result := l_result\n\n\n\n\n\n\n\n\nend\n\n\n  end if;\n\n\n\n\n\n\n\n\n\n\n  \n  l_result := l_result\n\n\n\n\n\n\n\n\nreturn\n\n\n  \n  return xmltype(l_result);\n\n\n\n\n\n\n\n\nl_source_column\n\n\n  l_source_column varchar2(500) := a_table_alias\n\n\n\n\n\n\n\n\nend\n\n\n  end if;\n\n\n\n\n\n\n\n\nreturn\n\n\n  return l_filter;\n\n\n\n\n\n\n\n\n\n\nGET_COLUMNS_ROW_FILTER Function\n\n\n\n\nCurrent get column filter shaving off ROW tag during extract, this not working well with include and XMLTABLE option\nso when there is extract we artificially inject removed tag\n\n\n\n\n\nSyntax\n\n\nfunction get_columns_row_filter(\n  a_exclude_xpath varchar2, a_include_xpath varchar2,\n  a_table_alias varchar2 := 'ucd', a_column_alias varchar2 := 'item_data'\n) return varchar2", 
            "title": "UT_COMPOUND_DATA_HELPER"
        }, 
        {
            "location": "/ut_compound_data_helper/#ut_compound_data_helper", 
            "text": "Constants    Variables    Exceptions    GET_COLUMNS_ROW_FILTER Function", 
            "title": "UT_COMPOUND_DATA_HELPER"
        }, 
        {
            "location": "/ut_compound_data_helper/#variables", 
            "text": "Name  Code  Description      g_user_defined_type  g_user_defined_type pls_integer := dbms_sql.user_defined_type;     l_res    l_res xmltype;     l_data    l_data ut_data_value := a_column_details.value;     l_key    l_key varchar2(4000) := ut_utils.xmlgen_escaped_string(a_column_details.KEY);     begin  begin   l_result := ' '     else    else     l_result := l_result     end    end if;           l_result := l_result     return       return xmltype(l_result);     l_source_column    l_source_column varchar2(500) := a_table_alias     end    end if;     return    return l_filter;", 
            "title": "Variables"
        }, 
        {
            "location": "/ut_compound_data_helper/#constants", 
            "text": "Name  Code  Description      gc_compare_join_by  gc_compare_join_by   constant varchar2(10):='join_by';     gc_compare_unordered  gc_compare_unordered constant varchar2(10):='unordered';     gc_compare_normal  gc_compare_normal    constant varchar2(10):='normal';", 
            "title": "Constants"
        }, 
        {
            "location": "/ut_compound_data_helper/#exceptions", 
            "text": "Name  Code  Description      g_user_defined_type  g_user_defined_type pls_integer := dbms_sql.user_defined_type;     l_res    l_res xmltype;     l_data    l_data ut_data_value := a_column_details.value;     l_key    l_key varchar2(4000) := ut_utils.xmlgen_escaped_string(a_column_details.KEY);     begin  begin   l_result := ' '     else    else     l_result := l_result     end    end if;           l_result := l_result     return       return xmltype(l_result);     l_source_column    l_source_column varchar2(500) := a_table_alias     end    end if;     return    return l_filter;", 
            "title": "Exceptions"
        }, 
        {
            "location": "/ut_compound_data_helper/#get_columns_row_filter-function", 
            "text": "Current get column filter shaving off ROW tag during extract, this not working well with include and XMLTABLE option so when there is extract we artificially inject removed tag", 
            "title": "GET_COLUMNS_ROW_FILTER Function"
        }, 
        {
            "location": "/ut_compound_data_helper/#syntax", 
            "text": "function get_columns_row_filter(\n  a_exclude_xpath varchar2, a_include_xpath varchar2,\n  a_table_alias varchar2 := 'ucd', a_column_alias varchar2 := 'item_data'\n) return varchar2", 
            "title": "Syntax"
        }, 
        {
            "location": "/ut_coverage/", 
            "text": "UT_COVERAGE\n\n\n\n\n\n\nConstants\n\n\n\n\n\n\nVariables\n\n\n\n\n\n\nExceptions\n\n\n\n\n\n\nCOVERAGE_START Procedure\n\n\n\n\nMOCK_COVERAGE_ID Procedure\n\n\n\n\nVariables\n\n\n\n\n\n\n\n\nName\n\n\nCode\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ng_coverage_id\n\n\ng_coverage_id   tt_coverage_id_arr;\n\n\n\n\n\n\n\n\ng_develop_mode\n\n\ng_develop_mode  boolean not null := false;\n\n\n\n\n\n\n\n\ng_is_started\n\n\ng_is_started    boolean not null := false;\n\n\n\n\n\n\n\n\nl_full_name\n\n\n  l_full_name varchar2(100);\n\n\n\n\n\n\n\n\nl_view_name\n\n\n  l_view_name      varchar2(200) := ut_metadata.get_dba_view('dba_source');\n\n\n\n\n\n\n\n\nelse\n\n\n  else\n    l_full_name := 'lower(s.owner\n\n\n\n\n\n\n\n\nend\n\n\n  end if;\n\n\n\n\n\n\n\n\n\n\n  l_result := l_result\n\n\n\n\n\n\n\n\nend\n\n\n  end if;\n\n\n\n\n\n\n\n\nreturn\n\n\n  return l_result;\n\n\n\n\n\n\n\n\nl_skip_objects\n\n\n  l_skip_objects  ut_object_names;\n\n\n\n\n\n\n\n\nl_sql\n\n\n  l_sql           varchar2(32767);\n\n\n\n\n\n\n\n\nend\n\n\n  end if;\n\n\n\n\n\n\n\n\n\n\n  l_sql := a_sql;\n\n\n\n\n\n\n\n\nelse\n\n\n  else\n    open l_cursor for l_sql using a_coverage_options.schema_names, l_skip_objects;\n\n\n\n\n\n\n\n\nend\n\n\n  end if;\n\n\n\n\n\n\n\n\nreturn\n\n\n  return l_cursor;\n\n\n\n\n\n\n\n\nl_cov_sources_crsr\n\n\n  l_cov_sources_crsr sys_refcursor;\n\n\n\n\n\n\n\n\nl_cov_sources_data\n\n\n  l_cov_sources_data ut_coverage_helper.t_coverage_sources_tmp_rows;\n\n\n\n\n\n\n\n\n\n\n    l_cov_sources_crsr := get_cov_sources_cursor(a_coverage_options,a_sql);\n\n\n\n\n\n\n\n\nloop\n\n\n    loop\n      fetch l_cov_sources_crsr bulk collect into l_cov_sources_data limit 1000;\n\n\n\n\n\n\n\n\nexit\n\n\n      exit when l_cov_sources_crsr%notfound;\n\n\n\n\n\n\n\n\nend\n\n\n    end loop;\n\n\n\n\n\n\n\n\nclose\n\n\n    close l_cov_sources_crsr;\n\n\n\n\n\n\n\n\nend\n\n\n  end if;\n\n\n\n\n\n\n\n\n\n\nConstants\n\n\n\n\n\n\n\n\nName\n\n\nCode\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ngc_proftab_coverage\n\n\ngc_proftab_coverage    constant varchar2(32) := 'proftab';\n\n\n\n\n\n\n\n\ngc_block_coverage\n\n\ngc_block_coverage      constant varchar2(32) := 'block';\n\n\n\n\n\n\n\n\ngc_extended_coverage\n\n\ngc_extended_coverage   constant varchar2(32) := 'extended';\n\n\n\n\n\n\n\n\n\n\nExceptions\n\n\n\n\n\n\n\n\nName\n\n\nCode\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ng_coverage_id\n\n\ng_coverage_id   tt_coverage_id_arr;\n\n\n\n\n\n\n\n\ng_develop_mode\n\n\ng_develop_mode  boolean not null := false;\n\n\n\n\n\n\n\n\ng_is_started\n\n\ng_is_started    boolean not null := false;\n\n\n\n\n\n\n\n\nl_full_name\n\n\n  l_full_name varchar2(100);\n\n\n\n\n\n\n\n\nl_view_name\n\n\n  l_view_name      varchar2(200) := ut_metadata.get_dba_view('dba_source');\n\n\n\n\n\n\n\n\nelse\n\n\n  else\n    l_full_name := 'lower(s.owner\n\n\n\n\n\n\n\n\nend\n\n\n  end if;\n\n\n\n\n\n\n\n\n\n\n  l_result := l_result\n\n\n\n\n\n\n\n\nend\n\n\n  end if;\n\n\n\n\n\n\n\n\nreturn\n\n\n  return l_result;\n\n\n\n\n\n\n\n\nl_skip_objects\n\n\n  l_skip_objects  ut_object_names;\n\n\n\n\n\n\n\n\nl_sql\n\n\n  l_sql           varchar2(32767);\n\n\n\n\n\n\n\n\nend\n\n\n  end if;\n\n\n\n\n\n\n\n\n\n\n  l_sql := a_sql;\n\n\n\n\n\n\n\n\nelse\n\n\n  else\n    open l_cursor for l_sql using a_coverage_options.schema_names, l_skip_objects;\n\n\n\n\n\n\n\n\nend\n\n\n  end if;\n\n\n\n\n\n\n\n\nreturn\n\n\n  return l_cursor;\n\n\n\n\n\n\n\n\nl_cov_sources_crsr\n\n\n  l_cov_sources_crsr sys_refcursor;\n\n\n\n\n\n\n\n\nl_cov_sources_data\n\n\n  l_cov_sources_data ut_coverage_helper.t_coverage_sources_tmp_rows;\n\n\n\n\n\n\n\n\n\n\n    l_cov_sources_crsr := get_cov_sources_cursor(a_coverage_options,a_sql);\n\n\n\n\n\n\n\n\nloop\n\n\n    loop\n      fetch l_cov_sources_crsr bulk collect into l_cov_sources_data limit 1000;\n\n\n\n\n\n\n\n\nexit\n\n\n      exit when l_cov_sources_crsr%notfound;\n\n\n\n\n\n\n\n\nend\n\n\n    end loop;\n\n\n\n\n\n\n\n\nclose\n\n\n    close l_cov_sources_crsr;\n\n\n\n\n\n\n\n\nend\n\n\n  end if;\n\n\n\n\n\n\n\n\n\n\nCOVERAGE_START Procedure\n\n\n\n\nPublic functions\n\n\n\n\n\nSyntax\n\n\nprocedure coverage_start(a_coverage_options ut_coverage_options default null)\n\n\n\n\nMOCK_COVERAGE_ID Procedure\n\n\n\n\n*\nAllows overwriting of private global variable g_coverage_id\nUsed internally, only for unit testing of the framework only\n\n\n\n\n\nSyntax\n\n\nprocedure mock_coverage_id(a_coverage_id integer,a_coverage_type in varchar2)", 
            "title": "UT_COVERAGE"
        }, 
        {
            "location": "/ut_coverage/#ut_coverage", 
            "text": "Constants    Variables    Exceptions    COVERAGE_START Procedure   MOCK_COVERAGE_ID Procedure", 
            "title": "UT_COVERAGE"
        }, 
        {
            "location": "/ut_coverage/#variables", 
            "text": "Name  Code  Description      g_coverage_id  g_coverage_id   tt_coverage_id_arr;     g_develop_mode  g_develop_mode  boolean not null := false;     g_is_started  g_is_started    boolean not null := false;     l_full_name    l_full_name varchar2(100);     l_view_name    l_view_name      varchar2(200) := ut_metadata.get_dba_view('dba_source');     else    else     l_full_name := 'lower(s.owner     end    end if;        l_result := l_result     end    end if;     return    return l_result;     l_skip_objects    l_skip_objects  ut_object_names;     l_sql    l_sql           varchar2(32767);     end    end if;        l_sql := a_sql;     else    else     open l_cursor for l_sql using a_coverage_options.schema_names, l_skip_objects;     end    end if;     return    return l_cursor;     l_cov_sources_crsr    l_cov_sources_crsr sys_refcursor;     l_cov_sources_data    l_cov_sources_data ut_coverage_helper.t_coverage_sources_tmp_rows;          l_cov_sources_crsr := get_cov_sources_cursor(a_coverage_options,a_sql);     loop      loop       fetch l_cov_sources_crsr bulk collect into l_cov_sources_data limit 1000;     exit        exit when l_cov_sources_crsr%notfound;     end      end loop;     close      close l_cov_sources_crsr;     end    end if;", 
            "title": "Variables"
        }, 
        {
            "location": "/ut_coverage/#constants", 
            "text": "Name  Code  Description      gc_proftab_coverage  gc_proftab_coverage    constant varchar2(32) := 'proftab';     gc_block_coverage  gc_block_coverage      constant varchar2(32) := 'block';     gc_extended_coverage  gc_extended_coverage   constant varchar2(32) := 'extended';", 
            "title": "Constants"
        }, 
        {
            "location": "/ut_coverage/#exceptions", 
            "text": "Name  Code  Description      g_coverage_id  g_coverage_id   tt_coverage_id_arr;     g_develop_mode  g_develop_mode  boolean not null := false;     g_is_started  g_is_started    boolean not null := false;     l_full_name    l_full_name varchar2(100);     l_view_name    l_view_name      varchar2(200) := ut_metadata.get_dba_view('dba_source');     else    else     l_full_name := 'lower(s.owner     end    end if;        l_result := l_result     end    end if;     return    return l_result;     l_skip_objects    l_skip_objects  ut_object_names;     l_sql    l_sql           varchar2(32767);     end    end if;        l_sql := a_sql;     else    else     open l_cursor for l_sql using a_coverage_options.schema_names, l_skip_objects;     end    end if;     return    return l_cursor;     l_cov_sources_crsr    l_cov_sources_crsr sys_refcursor;     l_cov_sources_data    l_cov_sources_data ut_coverage_helper.t_coverage_sources_tmp_rows;          l_cov_sources_crsr := get_cov_sources_cursor(a_coverage_options,a_sql);     loop      loop       fetch l_cov_sources_crsr bulk collect into l_cov_sources_data limit 1000;     exit        exit when l_cov_sources_crsr%notfound;     end      end loop;     close      close l_cov_sources_crsr;     end    end if;", 
            "title": "Exceptions"
        }, 
        {
            "location": "/ut_coverage/#coverage_start-procedure", 
            "text": "Public functions", 
            "title": "COVERAGE_START Procedure"
        }, 
        {
            "location": "/ut_coverage/#syntax", 
            "text": "procedure coverage_start(a_coverage_options ut_coverage_options default null)", 
            "title": "Syntax"
        }, 
        {
            "location": "/ut_coverage/#mock_coverage_id-procedure", 
            "text": "* Allows overwriting of private global variable g_coverage_id Used internally, only for unit testing of the framework only", 
            "title": "MOCK_COVERAGE_ID Procedure"
        }, 
        {
            "location": "/ut_coverage/#syntax_1", 
            "text": "procedure mock_coverage_id(a_coverage_id integer,a_coverage_type in varchar2)", 
            "title": "Syntax"
        }, 
        {
            "location": "/ut_coverage_block/", 
            "text": "UT_COVERAGE_BLOCK\n\n\n\n\n\n\nData Types\n\n\n\n\n\n\nGET_COVERAGE_DATA Function\n\n\n\n\n\n\nTypes\n\n\n\n\n\n\n\n\nName\n\n\nCode\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nt_source_lines\n\n\ntype t_source_lines is table of binary_integer;\n\n\n\n\n\n\n\n\n\n\nGET_COVERAGE_DATA Function\n\n\n\n\nPublic functions\n\n\n\n\n\nSyntax\n\n\nfunction get_coverage_data(a_coverage_options ut_coverage_options, a_coverage_id integer) return ut_coverage.t_coverage", 
            "title": "UT_COVERAGE_BLOCK"
        }, 
        {
            "location": "/ut_coverage_block/#ut_coverage_block", 
            "text": "Data Types    GET_COVERAGE_DATA Function", 
            "title": "UT_COVERAGE_BLOCK"
        }, 
        {
            "location": "/ut_coverage_block/#types", 
            "text": "Name  Code  Description      t_source_lines  type t_source_lines is table of binary_integer;", 
            "title": "Types"
        }, 
        {
            "location": "/ut_coverage_block/#get_coverage_data-function", 
            "text": "Public functions", 
            "title": "GET_COVERAGE_DATA Function"
        }, 
        {
            "location": "/ut_coverage_block/#syntax", 
            "text": "function get_coverage_data(a_coverage_options ut_coverage_options, a_coverage_id integer) return ut_coverage.t_coverage", 
            "title": "Syntax"
        }, 
        {
            "location": "/ut_coverage_helper/", 
            "text": "UT_COVERAGE_HELPER\n\n\n\n\nData Types\n\n\n\n\nTypes\n\n\n\n\n\n\n\n\nName\n\n\nCode\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nt_proftab_row\n\n\ntype t_proftab_row is record (\n    line  binary_integer,\n    calls number(38,0)\n  );\n\n\n\n\n\n\n\n\nt_proftab_rows\n\n\n  \ntype t_proftab_rows is table of t_proftab_row;\n\n\n\n\n\n\n\n\nt_block_row\n\n\ntype t_block_row is record(\n     line           binary_integer\n    ,blocks         binary_integer\n    ,covered_blocks binary_integer);\n\n\n\n\n\n\n\n\nt_block_rows\n\n\ntype t_block_rows is table of t_block_row;", 
            "title": "UT_COVERAGE_HELPER"
        }, 
        {
            "location": "/ut_coverage_helper/#ut_coverage_helper", 
            "text": "Data Types", 
            "title": "UT_COVERAGE_HELPER"
        }, 
        {
            "location": "/ut_coverage_helper/#types", 
            "text": "Name  Code  Description      t_proftab_row  type t_proftab_row is record (     line  binary_integer,     calls number(38,0)   );     t_proftab_rows     type t_proftab_rows is table of t_proftab_row;     t_block_row  type t_block_row is record(      line           binary_integer     ,blocks         binary_integer     ,covered_blocks binary_integer);     t_block_rows  type t_block_rows is table of t_block_row;", 
            "title": "Types"
        }, 
        {
            "location": "/ut_coverage_helper_block/", 
            "text": "UT_COVERAGE_HELPER_BLOCK\n\n\n\n\n\n\nData Types\n\n\n\n\n\n\nCOVERAGE_START Procedure\n\n\n\n\n\n\nTypes\n\n\n\n\n\n\n\n\nName\n\n\nCode\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nt_proftab_row\n\n\ntype t_proftab_row is record (\n    line  binary_integer,\n    calls number(38,0)\n  );\n\n\n\n\n\n\n\n\nt_proftab_rows\n\n\n  \ntype t_proftab_rows is table of t_proftab_row;\n\n\n\n\n\n\n\n\nt_block_row\n\n\ntype t_block_row is record(\n     line           binary_integer\n    ,blocks         binary_integer\n    ,covered_blocks binary_integer);\n\n\n\n\n\n\n\n\nt_block_rows\n\n\ntype t_block_rows is table of t_block_row;\n\n\n\n\n\n\n\n\n\n\nCOVERAGE_START Procedure\n\n\n\n\nutPLSQL - Version 3\n  Copyright 2016 - 2017 utPLSQL Project\n  Licensed under the Apache License, Version 2.0 (the \nLicense\n):\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n  http://www.apache.org/licenses/LICENSE-2.0\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \nAS IS\n BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n\n\n\n\n\nSyntax\n\n\nprocedure coverage_start(a_run_comment in varchar2,a_coverage_id out integer)", 
            "title": "UT_COVERAGE_HELPER_BLOCK"
        }, 
        {
            "location": "/ut_coverage_helper_block/#ut_coverage_helper_block", 
            "text": "Data Types    COVERAGE_START Procedure", 
            "title": "UT_COVERAGE_HELPER_BLOCK"
        }, 
        {
            "location": "/ut_coverage_helper_block/#types", 
            "text": "Name  Code  Description      t_proftab_row  type t_proftab_row is record (     line  binary_integer,     calls number(38,0)   );     t_proftab_rows     type t_proftab_rows is table of t_proftab_row;     t_block_row  type t_block_row is record(      line           binary_integer     ,blocks         binary_integer     ,covered_blocks binary_integer);     t_block_rows  type t_block_rows is table of t_block_row;", 
            "title": "Types"
        }, 
        {
            "location": "/ut_coverage_helper_block/#coverage_start-procedure", 
            "text": "utPLSQL - Version 3   Copyright 2016 - 2017 utPLSQL Project   Licensed under the Apache License, Version 2.0 (the  License ):   you may not use this file except in compliance with the License.   You may obtain a copy of the License at   http://www.apache.org/licenses/LICENSE-2.0   Unless required by applicable law or agreed to in writing, software   distributed under the License is distributed on an  AS IS  BASIS,   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   See the License for the specific language governing permissions and   limitations under the License.", 
            "title": "COVERAGE_START Procedure"
        }, 
        {
            "location": "/ut_coverage_helper_block/#syntax", 
            "text": "procedure coverage_start(a_run_comment in varchar2,a_coverage_id out integer)", 
            "title": "Syntax"
        }, 
        {
            "location": "/ut_coverage_helper_profiler/", 
            "text": "UT_COVERAGE_HELPER_PROFILER\n\n\n\n\n\n\nData Types\n\n\n\n\n\n\nCOVERAGE_START Procedure\n\n\n\n\n\n\nTypes\n\n\n\n\n\n\n\n\nName\n\n\nCode\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nt_proftab_row\n\n\ntype t_proftab_row is record (\n    line  binary_integer,\n    calls number(38,0)\n  );\n\n\n\n\n\n\n\n\nt_proftab_rows\n\n\n  \ntype t_proftab_rows is table of t_proftab_row;\n\n\n\n\n\n\n\n\nt_block_row\n\n\ntype t_block_row is record(\n     line           binary_integer\n    ,blocks         binary_integer\n    ,covered_blocks binary_integer);\n\n\n\n\n\n\n\n\nt_block_rows\n\n\ntype t_block_rows is table of t_block_row;\n\n\n\n\n\n\n\n\n\n\nCOVERAGE_START Procedure\n\n\n\n\nutPLSQL - Version 3\n  Copyright 2016 - 2017 utPLSQL Project\n  Licensed under the Apache License, Version 2.0 (the \nLicense\n):\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n  http://www.apache.org/licenses/LICENSE-2.0\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \nAS IS\n BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n\n\n\n\n\nSyntax\n\n\nprocedure coverage_start(a_run_comment in varchar2,a_coverage_id out integer)", 
            "title": "UT_COVERAGE_HELPER_PROFILER"
        }, 
        {
            "location": "/ut_coverage_helper_profiler/#ut_coverage_helper_profiler", 
            "text": "Data Types    COVERAGE_START Procedure", 
            "title": "UT_COVERAGE_HELPER_PROFILER"
        }, 
        {
            "location": "/ut_coverage_helper_profiler/#types", 
            "text": "Name  Code  Description      t_proftab_row  type t_proftab_row is record (     line  binary_integer,     calls number(38,0)   );     t_proftab_rows     type t_proftab_rows is table of t_proftab_row;     t_block_row  type t_block_row is record(      line           binary_integer     ,blocks         binary_integer     ,covered_blocks binary_integer);     t_block_rows  type t_block_rows is table of t_block_row;", 
            "title": "Types"
        }, 
        {
            "location": "/ut_coverage_helper_profiler/#coverage_start-procedure", 
            "text": "utPLSQL - Version 3   Copyright 2016 - 2017 utPLSQL Project   Licensed under the Apache License, Version 2.0 (the  License ):   you may not use this file except in compliance with the License.   You may obtain a copy of the License at   http://www.apache.org/licenses/LICENSE-2.0   Unless required by applicable law or agreed to in writing, software   distributed under the License is distributed on an  AS IS  BASIS,   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   See the License for the specific language governing permissions and   limitations under the License.", 
            "title": "COVERAGE_START Procedure"
        }, 
        {
            "location": "/ut_coverage_helper_profiler/#syntax", 
            "text": "procedure coverage_start(a_run_comment in varchar2,a_coverage_id out integer)", 
            "title": "Syntax"
        }, 
        {
            "location": "/ut_coverage_profiler/", 
            "text": "UT_COVERAGE_PROFILER\n\n\n\n\nGET_COVERAGE_DATA Function\n\n\n\n\nGET_COVERAGE_DATA Function\n\n\n\n\nPublic functions\n\n\n\n\n\nSyntax\n\n\nfunction get_coverage_data(a_coverage_options ut_coverage_options, a_coverage_id integer) return ut_coverage.t_coverage", 
            "title": "UT_COVERAGE_PROFILER"
        }, 
        {
            "location": "/ut_coverage_profiler/#ut_coverage_profiler", 
            "text": "GET_COVERAGE_DATA Function", 
            "title": "UT_COVERAGE_PROFILER"
        }, 
        {
            "location": "/ut_coverage_profiler/#get_coverage_data-function", 
            "text": "Public functions", 
            "title": "GET_COVERAGE_DATA Function"
        }, 
        {
            "location": "/ut_coverage_profiler/#syntax", 
            "text": "function get_coverage_data(a_coverage_options ut_coverage_options, a_coverage_id integer) return ut_coverage.t_coverage", 
            "title": "Syntax"
        }, 
        {
            "location": "/ut_coverage_report_html_helper/", 
            "text": "UT_COVERAGE_REPORT_HTML_HELPER\n\n\n\n\n\n\nConstants\n\n\n\n\n\n\nGET_INDEX Function\n\n\n\n\nGET_DEFAULT_HTML_ASSETS_PATH Function\n\n\n\n\nConstants\n\n\n\n\n\n\n\n\nName\n\n\nCode\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ngc_green_coverage_pct\n\n\ngc_green_coverage_pct  constant integer := 90;\n\n\n\n\n\n\n\n\ngc_yellow_coverage_pct\n\n\ngc_yellow_coverage_pct constant integer := 80;\n\n\n\n\n\n\n\n\ngc_green_css\n\n\ngc_green_css  constant varchar2(10) := 'green';\n\n\n\n\n\n\n\n\ngc_yellow_css\n\n\ngc_yellow_css constant varchar2(10) := 'yellow';\n\n\n\n\n\n\n\n\ngc_red_css\n\n\ngc_red_css    constant varchar2(10) := 'red';\n\n\n\n\n\n\n\n\ngc_missed\n\n\ngc_missed      constant varchar2(7) := 'missed';\n\n\n\n\n\n\n\n\ngc_skipped\n\n\ngc_skipped     constant varchar2(7) := 'skipped';\n\n\n\n\n\n\n\n\ngc_disabled\n\n\ngc_disabled    constant varchar2(7) := 'never';\n\n\n\n\n\n\n\n\ngc_covered\n\n\ngc_covered     constant varchar2(7) := 'covered';\n\n\n\n\n\n\n\n\ngc_partcovered\n\n\ngc_partcovered constant varchar2(7) := 'partcov';\n\n\n\n\n\n\n\n\n\n\nGET_INDEX Function\n\n\n\n\npublic definitions\n\n\n\n\n\nSyntax\n\n\nfunction get_index(\n  a_coverage_data ut_coverage.t_coverage,\n  a_assets_path   varchar2,\n  a_project_name  varchar2 := null,\n  a_command_line  varchar2 := null,\n  a_charset       varchar2 := null\n) return clob\n\n\n\n\nGET_DEFAULT_HTML_ASSETS_PATH Function\n\n\n\n\nutPLSQL - Version 3\n  Copyright 2016 - 2017 utPLSQL Project\n  Licensed under the Apache License, Version 2.0 (the \nLicense\n):\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n  http://www.apache.org/licenses/LICENSE-2.0\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \nAS IS\n BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n\n\n\n\n\nSyntax\n\n\nfunction get_default_html_assets_path return varchar2 deterministic", 
            "title": "UT_COVERAGE_REPORT_HTML_HELPER"
        }, 
        {
            "location": "/ut_coverage_report_html_helper/#ut_coverage_report_html_helper", 
            "text": "Constants    GET_INDEX Function   GET_DEFAULT_HTML_ASSETS_PATH Function", 
            "title": "UT_COVERAGE_REPORT_HTML_HELPER"
        }, 
        {
            "location": "/ut_coverage_report_html_helper/#constants", 
            "text": "Name  Code  Description      gc_green_coverage_pct  gc_green_coverage_pct  constant integer := 90;     gc_yellow_coverage_pct  gc_yellow_coverage_pct constant integer := 80;     gc_green_css  gc_green_css  constant varchar2(10) := 'green';     gc_yellow_css  gc_yellow_css constant varchar2(10) := 'yellow';     gc_red_css  gc_red_css    constant varchar2(10) := 'red';     gc_missed  gc_missed      constant varchar2(7) := 'missed';     gc_skipped  gc_skipped     constant varchar2(7) := 'skipped';     gc_disabled  gc_disabled    constant varchar2(7) := 'never';     gc_covered  gc_covered     constant varchar2(7) := 'covered';     gc_partcovered  gc_partcovered constant varchar2(7) := 'partcov';", 
            "title": "Constants"
        }, 
        {
            "location": "/ut_coverage_report_html_helper/#get_index-function", 
            "text": "public definitions", 
            "title": "GET_INDEX Function"
        }, 
        {
            "location": "/ut_coverage_report_html_helper/#syntax", 
            "text": "function get_index(\n  a_coverage_data ut_coverage.t_coverage,\n  a_assets_path   varchar2,\n  a_project_name  varchar2 := null,\n  a_command_line  varchar2 := null,\n  a_charset       varchar2 := null\n) return clob", 
            "title": "Syntax"
        }, 
        {
            "location": "/ut_coverage_report_html_helper/#get_default_html_assets_path-function", 
            "text": "utPLSQL - Version 3   Copyright 2016 - 2017 utPLSQL Project   Licensed under the Apache License, Version 2.0 (the  License ):   you may not use this file except in compliance with the License.   You may obtain a copy of the License at   http://www.apache.org/licenses/LICENSE-2.0   Unless required by applicable law or agreed to in writing, software   distributed under the License is distributed on an  AS IS  BASIS,   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   See the License for the specific language governing permissions and   limitations under the License.", 
            "title": "GET_DEFAULT_HTML_ASSETS_PATH Function"
        }, 
        {
            "location": "/ut_coverage_report_html_helper/#syntax_1", 
            "text": "function get_default_html_assets_path return varchar2 deterministic", 
            "title": "Syntax"
        }, 
        {
            "location": "/ut_curr_usr_compound_helper/", 
            "text": "UT_CURR_USR_COMPOUND_HELPER\n\n\n\n\n\n\nVariables\n\n\n\n\n\n\nExceptions\n\n\n\n\n\n\nVariables\n\n\n\n\n\n\n\n\nName\n\n\nCode\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nend\n\n\nend if;\n\n\n\n\n\n\n\n\nreturn\n\n\nreturn ut_key_anyval_pair(a_desc_rec.col_name,l_data);\n\n\n\n\n\n\n\n\nend\n\n\nend loop;\n\n\n\n\n\n\n\n\nreturn\n\n\nreturn l_result;\n\n\n\n\n\n\n\n\nl_columns_count\n\n\n    l_columns_count  pls_integer;\n\n\n\n\n\n\n\n\nl_columns_desc\n\n\n    l_columns_desc   dbms_sql.desc_tab3;\n\n\n\n\n\n\n\n\nl_columns_tab\n\n\n    l_columns_tab    ut_key_anyval_pairs;\n\n\n\n\n\n\n\n\nend\n\n\n    end if;\n\n\n\n\n\n\n\n\n\n\n    l_cursor_number := dbms_sql.to_cursor_number( a_cursor );\n\n\n\n\n\n\n\n\n\n\n    a_cursor := dbms_sql.to_refcursor( l_cursor_number );\n\n\n\n\n\n\n\n\n\n\n    l_columns_tab := get_columns_info( l_columns_desc, l_columns_count, a_desc_user_types);\n\n\n\n\n\n\n\n\nreturn\n\n\n    return l_columns_tab;\n\n\n\n\n\n\n\n\nl_columns_count\n\n\n    l_columns_count  pls_integer;\n\n\n\n\n\n\n\n\nl_columns_desc\n\n\n    l_columns_desc   dbms_sql.desc_tab3;\n\n\n\n\n\n\n\n\n\n\n  a_join_by_tab := null;\n\n\n\n\n\n\n\n\nend\n\n\n    end if;\n\n\n\n\n\n\n\n\n\n\n    l_cursor_number := dbms_sql.to_cursor_number( a_cursor );\n\n\n\n\n\n\n\n\n\n\n    a_cursor := dbms_sql.to_refcursor( l_cursor_number );\n\n\n\n\n\n\n\n\n\n\n    a_columns_tab := get_columns_info( l_columns_desc, l_columns_count, false);\n\n\n\n\n\n\n\n\n\n\n    a_join_by_tab := get_columns_info( l_columns_desc, l_columns_count, true);\n\n\n\n\n\n\n\n\nl_join_by_info\n\n\n    l_join_by_info         xmltype;\n\n\n\n\n\n\n\n\nl_result_tmp\n\n\n    l_result_tmp           xmltype;\n\n\n\n\n\n\n\n\nl_columns_tab\n\n\n    l_columns_tab          ut_key_anyval_pairs;\n\n\n\n\n\n\n\n\nl_join_by_tab\n\n\n    l_join_by_tab          ut_key_anyval_pairs;\n\n\n\n\n\n\n\n\nbegin\n\n\n  begin\n    \n    get_descr_cursor(a_cursor,l_columns_tab,l_join_by_tab);\n\n\n\n\n\n\n\n\nselect\n\n\nselect xmlconcat(l_columns_info,l_result_tmp) into l_columns_info from dual;\n\n\n\n\n\n\n\n\nend\n\n\n \n    end loop;\n\n\n\n\n\n\n\n\nselect\n\n\nselect xmlconcat(l_join_by_info,l_result_tmp) into l_join_by_info from dual;\n\n\n\n\n\n\n\n\nend\n\n\n \n    end loop;\n\n\n\n\n\n\n\n\n\n\n   \n    a_contains_collection := ut_utils.boolean_to_int(g_is_collection);\n\n\n\n\n\n\n\n\nl_result_tmp\n\n\n    l_result_tmp     xmltype;\n\n\n\n\n\n\n\n\nl_columns_tab\n\n\n    l_columns_tab    ut_key_anyval_pairs;\n\n\n\n\n\n\n\n\nbegin\n\n\n    begin\nl_columns_tab := get_descr_cursor(a_cursor,a_desc_user_types);\n\n\n\n\n\n\n\n\nselect\n\n\n  select xmlconcat(l_result,l_result_tmp) into l_result from dual;\n\n\n\n\n\n\n\n\nend\n\n\n \nend loop;\n\n\n\n\n\n\n\n\nreturn\n\n\nreturn l_result;\n\n\n\n\n\n\n\n\nl_schema_name\n\n\n      l_schema_name              varchar2(32767);\n\n\n\n\n\n\n\n\nl_version\n\n\n      l_version                  varchar2(32767);\n\n\n\n\n\n\n\n\nl_type_name\n\n\n      l_type_name                varchar2(32767);\n\n\n\n\n\n\n\n\nl_attributes\n\n\n      l_attributes               pls_integer;\n\n\n\n\n\n\n\n\nl_prec\n\n\n      l_prec                     pls_integer;\n\n\n\n\n\n\n\n\nl_scale\n\n\n \n      l_scale                    pls_integer;\n\n\n\n\n\n\n\n\nl_len\n\n\n      l_len                      pls_integer;\n\n\n\n\n\n\n\n\nl_csid\n\n\n      l_csid                     pls_integer;\n\n\n\n\n\n\n\n\nl_csfrm\n\n\n      l_csfrm                    pls_integer;\n\n\n\n\n\n\n\n\nreturn\n\n\n             \n    return l_attributes;\n\n\n\n\n\n\n\n\nl_attribute_typecode\n\n\n    l_attribute_typecode pls_integer;\n\n\n\n\n\n\n\n\nl_aname\n\n\n    l_aname          varchar2(32767);\n\n\n\n\n\n\n\n\nl_prec\n\n\n    l_prec           pls_integer;\n\n\n\n\n\n\n\n\nl_scale\n\n\n \n    l_scale          pls_integer;\n\n\n\n\n\n\n\n\nl_len\n\n\n    l_len            pls_integer;\n\n\n\n\n\n\n\n\nl_csid\n\n\n    l_csid           pls_integer;\n\n\n\n\n\n\n\n\nl_csfrm\n\n\n    l_csfrm          pls_integer;\n\n\n\n\n\n\n\n\nl_attr_elt_type\n\n\n    l_attr_elt_type  anytype;\n\n\n\n\n\n\n\n\nend\n\n\n     end if;\n\n\n\n\n\n\n\n\nend\n\n\n    end loop;\n\n\n\n\n\n\n\n\nreturn\n\n\n    return l_result;\n\n\n\n\n\n\n\n\nl_anytype\n\n\n    l_anytype anytype;\n\n\n\n\n\n\n\n\nl_typecode\n\n\n    l_typecode pls_integer;\n\n\n\n\n\n\n\n\nl_result\n\n\n    l_result xmltype;\n\n\n\n\n\n\n\n\nl_columns_tab\n\n\n    l_columns_tab ut_key_value_pairs := ut_key_value_pairs();\n\n\n\n\n\n\n\n\n\n\n                 begin \n                   :anydata := anydata.convertobject(l_v);\n\n\n\n\n\n\n\n\n\n\n    \n    l_typecode := l_anydata.gettype(l_anytype);\n\n\n\n\n\n\n\n\n\n\n    l_columns_tab := get_anytype_attributes_info(l_anytype);\n\n\n\n\n\n\n\n\nreturn\n\n\n    \n    return l_result;\n\n\n\n\n\n\n\n\nbegin\n\n\n  \n  begin\n  g_anytype_name_map(dbms_types.typecode_date)             :=' DATE';\n\n\n\n\n\n\n\n\n\n\nExceptions\n\n\n\n\n\n\n\n\nName\n\n\nCode\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nend\n\n\nend if;\n\n\n\n\n\n\n\n\nreturn\n\n\nreturn ut_key_anyval_pair(a_desc_rec.col_name,l_data);\n\n\n\n\n\n\n\n\nend\n\n\nend loop;\n\n\n\n\n\n\n\n\nreturn\n\n\nreturn l_result;\n\n\n\n\n\n\n\n\nl_columns_count\n\n\n    l_columns_count  pls_integer;\n\n\n\n\n\n\n\n\nl_columns_desc\n\n\n    l_columns_desc   dbms_sql.desc_tab3;\n\n\n\n\n\n\n\n\nl_columns_tab\n\n\n    l_columns_tab    ut_key_anyval_pairs;\n\n\n\n\n\n\n\n\nend\n\n\n    end if;\n\n\n\n\n\n\n\n\n\n\n    l_cursor_number := dbms_sql.to_cursor_number( a_cursor );\n\n\n\n\n\n\n\n\n\n\n    a_cursor := dbms_sql.to_refcursor( l_cursor_number );\n\n\n\n\n\n\n\n\n\n\n    l_columns_tab := get_columns_info( l_columns_desc, l_columns_count, a_desc_user_types);\n\n\n\n\n\n\n\n\nreturn\n\n\n    return l_columns_tab;\n\n\n\n\n\n\n\n\nl_columns_count\n\n\n    l_columns_count  pls_integer;\n\n\n\n\n\n\n\n\nl_columns_desc\n\n\n    l_columns_desc   dbms_sql.desc_tab3;\n\n\n\n\n\n\n\n\n\n\n  a_join_by_tab := null;\n\n\n\n\n\n\n\n\nend\n\n\n    end if;\n\n\n\n\n\n\n\n\n\n\n    l_cursor_number := dbms_sql.to_cursor_number( a_cursor );\n\n\n\n\n\n\n\n\n\n\n    a_cursor := dbms_sql.to_refcursor( l_cursor_number );\n\n\n\n\n\n\n\n\n\n\n    a_columns_tab := get_columns_info( l_columns_desc, l_columns_count, false);\n\n\n\n\n\n\n\n\n\n\n    a_join_by_tab := get_columns_info( l_columns_desc, l_columns_count, true);\n\n\n\n\n\n\n\n\nl_join_by_info\n\n\n    l_join_by_info         xmltype;\n\n\n\n\n\n\n\n\nl_result_tmp\n\n\n    l_result_tmp           xmltype;\n\n\n\n\n\n\n\n\nl_columns_tab\n\n\n    l_columns_tab          ut_key_anyval_pairs;\n\n\n\n\n\n\n\n\nl_join_by_tab\n\n\n    l_join_by_tab          ut_key_anyval_pairs;\n\n\n\n\n\n\n\n\nbegin\n\n\n  begin\n    \n    get_descr_cursor(a_cursor,l_columns_tab,l_join_by_tab);\n\n\n\n\n\n\n\n\nselect\n\n\nselect xmlconcat(l_columns_info,l_result_tmp) into l_columns_info from dual;\n\n\n\n\n\n\n\n\nend\n\n\n \n    end loop;\n\n\n\n\n\n\n\n\nselect\n\n\nselect xmlconcat(l_join_by_info,l_result_tmp) into l_join_by_info from dual;\n\n\n\n\n\n\n\n\nend\n\n\n \n    end loop;\n\n\n\n\n\n\n\n\n\n\n   \n    a_contains_collection := ut_utils.boolean_to_int(g_is_collection);\n\n\n\n\n\n\n\n\nl_result_tmp\n\n\n    l_result_tmp     xmltype;\n\n\n\n\n\n\n\n\nl_columns_tab\n\n\n    l_columns_tab    ut_key_anyval_pairs;\n\n\n\n\n\n\n\n\nbegin\n\n\n    begin\nl_columns_tab := get_descr_cursor(a_cursor,a_desc_user_types);\n\n\n\n\n\n\n\n\nselect\n\n\n  select xmlconcat(l_result,l_result_tmp) into l_result from dual;\n\n\n\n\n\n\n\n\nend\n\n\n \nend loop;\n\n\n\n\n\n\n\n\nreturn\n\n\nreturn l_result;\n\n\n\n\n\n\n\n\nl_schema_name\n\n\n      l_schema_name              varchar2(32767);\n\n\n\n\n\n\n\n\nl_version\n\n\n      l_version                  varchar2(32767);\n\n\n\n\n\n\n\n\nl_type_name\n\n\n      l_type_name                varchar2(32767);\n\n\n\n\n\n\n\n\nl_attributes\n\n\n      l_attributes               pls_integer;\n\n\n\n\n\n\n\n\nl_prec\n\n\n      l_prec                     pls_integer;\n\n\n\n\n\n\n\n\nl_scale\n\n\n \n      l_scale                    pls_integer;\n\n\n\n\n\n\n\n\nl_len\n\n\n      l_len                      pls_integer;\n\n\n\n\n\n\n\n\nl_csid\n\n\n      l_csid                     pls_integer;\n\n\n\n\n\n\n\n\nl_csfrm\n\n\n      l_csfrm                    pls_integer;\n\n\n\n\n\n\n\n\nreturn\n\n\n             \n    return l_attributes;\n\n\n\n\n\n\n\n\nl_attribute_typecode\n\n\n    l_attribute_typecode pls_integer;\n\n\n\n\n\n\n\n\nl_aname\n\n\n    l_aname          varchar2(32767);\n\n\n\n\n\n\n\n\nl_prec\n\n\n    l_prec           pls_integer;\n\n\n\n\n\n\n\n\nl_scale\n\n\n \n    l_scale          pls_integer;\n\n\n\n\n\n\n\n\nl_len\n\n\n    l_len            pls_integer;\n\n\n\n\n\n\n\n\nl_csid\n\n\n    l_csid           pls_integer;\n\n\n\n\n\n\n\n\nl_csfrm\n\n\n    l_csfrm          pls_integer;\n\n\n\n\n\n\n\n\nl_attr_elt_type\n\n\n    l_attr_elt_type  anytype;\n\n\n\n\n\n\n\n\nend\n\n\n     end if;\n\n\n\n\n\n\n\n\nend\n\n\n    end loop;\n\n\n\n\n\n\n\n\nreturn\n\n\n    return l_result;\n\n\n\n\n\n\n\n\nl_anytype\n\n\n    l_anytype anytype;\n\n\n\n\n\n\n\n\nl_typecode\n\n\n    l_typecode pls_integer;\n\n\n\n\n\n\n\n\nl_result\n\n\n    l_result xmltype;\n\n\n\n\n\n\n\n\nl_columns_tab\n\n\n    l_columns_tab ut_key_value_pairs := ut_key_value_pairs();\n\n\n\n\n\n\n\n\n\n\n                 begin \n                   :anydata := anydata.convertobject(l_v);\n\n\n\n\n\n\n\n\n\n\n    \n    l_typecode := l_anydata.gettype(l_anytype);\n\n\n\n\n\n\n\n\n\n\n    l_columns_tab := get_anytype_attributes_info(l_anytype);\n\n\n\n\n\n\n\n\nreturn\n\n\n    \n    return l_result;\n\n\n\n\n\n\n\n\nbegin\n\n\n  \n  begin\n  g_anytype_name_map(dbms_types.typecode_date)             :=' DATE';", 
            "title": "UT_CURR_USR_COMPOUND_HELPER"
        }, 
        {
            "location": "/ut_curr_usr_compound_helper/#ut_curr_usr_compound_helper", 
            "text": "Variables    Exceptions", 
            "title": "UT_CURR_USR_COMPOUND_HELPER"
        }, 
        {
            "location": "/ut_curr_usr_compound_helper/#variables", 
            "text": "Name  Code  Description      end  end if;     return  return ut_key_anyval_pair(a_desc_rec.col_name,l_data);     end  end loop;     return  return l_result;     l_columns_count      l_columns_count  pls_integer;     l_columns_desc      l_columns_desc   dbms_sql.desc_tab3;     l_columns_tab      l_columns_tab    ut_key_anyval_pairs;     end      end if;          l_cursor_number := dbms_sql.to_cursor_number( a_cursor );          a_cursor := dbms_sql.to_refcursor( l_cursor_number );          l_columns_tab := get_columns_info( l_columns_desc, l_columns_count, a_desc_user_types);     return      return l_columns_tab;     l_columns_count      l_columns_count  pls_integer;     l_columns_desc      l_columns_desc   dbms_sql.desc_tab3;        a_join_by_tab := null;     end      end if;          l_cursor_number := dbms_sql.to_cursor_number( a_cursor );          a_cursor := dbms_sql.to_refcursor( l_cursor_number );          a_columns_tab := get_columns_info( l_columns_desc, l_columns_count, false);          a_join_by_tab := get_columns_info( l_columns_desc, l_columns_count, true);     l_join_by_info      l_join_by_info         xmltype;     l_result_tmp      l_result_tmp           xmltype;     l_columns_tab      l_columns_tab          ut_key_anyval_pairs;     l_join_by_tab      l_join_by_tab          ut_key_anyval_pairs;     begin    begin          get_descr_cursor(a_cursor,l_columns_tab,l_join_by_tab);     select  select xmlconcat(l_columns_info,l_result_tmp) into l_columns_info from dual;     end        end loop;     select  select xmlconcat(l_join_by_info,l_result_tmp) into l_join_by_info from dual;     end        end loop;              a_contains_collection := ut_utils.boolean_to_int(g_is_collection);     l_result_tmp      l_result_tmp     xmltype;     l_columns_tab      l_columns_tab    ut_key_anyval_pairs;     begin      begin l_columns_tab := get_descr_cursor(a_cursor,a_desc_user_types);     select    select xmlconcat(l_result,l_result_tmp) into l_result from dual;     end    end loop;     return  return l_result;     l_schema_name        l_schema_name              varchar2(32767);     l_version        l_version                  varchar2(32767);     l_type_name        l_type_name                varchar2(32767);     l_attributes        l_attributes               pls_integer;     l_prec        l_prec                     pls_integer;     l_scale          l_scale                    pls_integer;     l_len        l_len                      pls_integer;     l_csid        l_csid                     pls_integer;     l_csfrm        l_csfrm                    pls_integer;     return                    return l_attributes;     l_attribute_typecode      l_attribute_typecode pls_integer;     l_aname      l_aname          varchar2(32767);     l_prec      l_prec           pls_integer;     l_scale        l_scale          pls_integer;     l_len      l_len            pls_integer;     l_csid      l_csid           pls_integer;     l_csfrm      l_csfrm          pls_integer;     l_attr_elt_type      l_attr_elt_type  anytype;     end       end if;     end      end loop;     return      return l_result;     l_anytype      l_anytype anytype;     l_typecode      l_typecode pls_integer;     l_result      l_result xmltype;     l_columns_tab      l_columns_tab ut_key_value_pairs := ut_key_value_pairs();                       begin                     :anydata := anydata.convertobject(l_v);               l_typecode := l_anydata.gettype(l_anytype);          l_columns_tab := get_anytype_attributes_info(l_anytype);     return           return l_result;     begin       begin   g_anytype_name_map(dbms_types.typecode_date)             :=' DATE';", 
            "title": "Variables"
        }, 
        {
            "location": "/ut_curr_usr_compound_helper/#exceptions", 
            "text": "Name  Code  Description      end  end if;     return  return ut_key_anyval_pair(a_desc_rec.col_name,l_data);     end  end loop;     return  return l_result;     l_columns_count      l_columns_count  pls_integer;     l_columns_desc      l_columns_desc   dbms_sql.desc_tab3;     l_columns_tab      l_columns_tab    ut_key_anyval_pairs;     end      end if;          l_cursor_number := dbms_sql.to_cursor_number( a_cursor );          a_cursor := dbms_sql.to_refcursor( l_cursor_number );          l_columns_tab := get_columns_info( l_columns_desc, l_columns_count, a_desc_user_types);     return      return l_columns_tab;     l_columns_count      l_columns_count  pls_integer;     l_columns_desc      l_columns_desc   dbms_sql.desc_tab3;        a_join_by_tab := null;     end      end if;          l_cursor_number := dbms_sql.to_cursor_number( a_cursor );          a_cursor := dbms_sql.to_refcursor( l_cursor_number );          a_columns_tab := get_columns_info( l_columns_desc, l_columns_count, false);          a_join_by_tab := get_columns_info( l_columns_desc, l_columns_count, true);     l_join_by_info      l_join_by_info         xmltype;     l_result_tmp      l_result_tmp           xmltype;     l_columns_tab      l_columns_tab          ut_key_anyval_pairs;     l_join_by_tab      l_join_by_tab          ut_key_anyval_pairs;     begin    begin          get_descr_cursor(a_cursor,l_columns_tab,l_join_by_tab);     select  select xmlconcat(l_columns_info,l_result_tmp) into l_columns_info from dual;     end        end loop;     select  select xmlconcat(l_join_by_info,l_result_tmp) into l_join_by_info from dual;     end        end loop;              a_contains_collection := ut_utils.boolean_to_int(g_is_collection);     l_result_tmp      l_result_tmp     xmltype;     l_columns_tab      l_columns_tab    ut_key_anyval_pairs;     begin      begin l_columns_tab := get_descr_cursor(a_cursor,a_desc_user_types);     select    select xmlconcat(l_result,l_result_tmp) into l_result from dual;     end    end loop;     return  return l_result;     l_schema_name        l_schema_name              varchar2(32767);     l_version        l_version                  varchar2(32767);     l_type_name        l_type_name                varchar2(32767);     l_attributes        l_attributes               pls_integer;     l_prec        l_prec                     pls_integer;     l_scale          l_scale                    pls_integer;     l_len        l_len                      pls_integer;     l_csid        l_csid                     pls_integer;     l_csfrm        l_csfrm                    pls_integer;     return                    return l_attributes;     l_attribute_typecode      l_attribute_typecode pls_integer;     l_aname      l_aname          varchar2(32767);     l_prec      l_prec           pls_integer;     l_scale        l_scale          pls_integer;     l_len      l_len            pls_integer;     l_csid      l_csid           pls_integer;     l_csfrm      l_csfrm          pls_integer;     l_attr_elt_type      l_attr_elt_type  anytype;     end       end if;     end      end loop;     return      return l_result;     l_anytype      l_anytype anytype;     l_typecode      l_typecode pls_integer;     l_result      l_result xmltype;     l_columns_tab      l_columns_tab ut_key_value_pairs := ut_key_value_pairs();                       begin                     :anydata := anydata.convertobject(l_v);               l_typecode := l_anydata.gettype(l_anytype);          l_columns_tab := get_anytype_attributes_info(l_anytype);     return           return l_result;     begin       begin   g_anytype_name_map(dbms_types.typecode_date)             :=' DATE';", 
            "title": "Exceptions"
        }, 
        {
            "location": "/ut_event_manager/", 
            "text": "UT_EVENT_MANAGER\n\n\n\n\nData Types\n\n\n\n\nTypes\n\n\n\n\n\n\n\n\nName\n\n\nCode\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nt_listeners\n\n\ntype t_listeners is table of ut_event_listener;\n\n\n\n\n\n\n\n\nt_listener_number\n\n\nsubtype t_listener_number is binary_integer;\n\n\n\n\n\n\n\n\nt_listener_numbers\n\n\ntype t_listener_numbers is table of boolean index by t_listener_number;\n\n\n\n\n\n\n\n\nt_events_listeners\n\n\ntype t_events_listeners is table of t_listener_numbers index by t_event_name;\n\n\n\n\n\n\n\n\nt_event_name\n\n\nsubtype t_event_name           is varchar2(250);", 
            "title": "UT_EVENT_MANAGER"
        }, 
        {
            "location": "/ut_event_manager/#ut_event_manager", 
            "text": "Data Types", 
            "title": "UT_EVENT_MANAGER"
        }, 
        {
            "location": "/ut_event_manager/#types", 
            "text": "Name  Code  Description      t_listeners  type t_listeners is table of ut_event_listener;     t_listener_number  subtype t_listener_number is binary_integer;     t_listener_numbers  type t_listener_numbers is table of boolean index by t_listener_number;     t_events_listeners  type t_events_listeners is table of t_listener_numbers index by t_event_name;     t_event_name  subtype t_event_name           is varchar2(250);", 
            "title": "Types"
        }, 
        {
            "location": "/ut_expectation_processor/", 
            "text": "UT_EXPECTATION_PROCESSOR\n\n\n\n\n\n\nData Types\n\n\n\n\n\n\nConstants\n\n\n\n\n\n\nTypes\n\n\n\n\n\n\n\n\nName\n\n\nCode\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ntt_nls_params\n\n\ntype tt_nls_params is table of nls_session_parameters%rowtype;\n\n\n\n\n\n\n\n\n\n\nConstants\n\n\n\n\n\n\n\n\nName\n\n\nCode\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ngc_default_nulls_are_equal\n\n\ngc_default_nulls_are_equal constant boolean := true;", 
            "title": "UT_EXPECTATION_PROCESSOR"
        }, 
        {
            "location": "/ut_expectation_processor/#ut_expectation_processor", 
            "text": "Data Types    Constants", 
            "title": "UT_EXPECTATION_PROCESSOR"
        }, 
        {
            "location": "/ut_expectation_processor/#types", 
            "text": "Name  Code  Description      tt_nls_params  type tt_nls_params is table of nls_session_parameters%rowtype;", 
            "title": "Types"
        }, 
        {
            "location": "/ut_expectation_processor/#constants", 
            "text": "Name  Code  Description      gc_default_nulls_are_equal  gc_default_nulls_are_equal constant boolean := true;", 
            "title": "Constants"
        }, 
        {
            "location": "/ut_file_mapper/", 
            "text": "UT_FILE_MAPPER\n\n\n\n\n\n\nData Types\n\n\n\n\n\n\nConstants\n\n\n\n\n\n\nTO_HASH_TABLE Function\n\n\n\n\nDEFAULT_FILE_TO_OBJ_TYPE_MAP Function\n\n\n\n\nTypes\n\n\n\n\n\n\n\n\nName\n\n\nCode\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ntt_key_values\n\n\ntype tt_key_values is table of varchar2(4000) index by varchar2(4000);\n\n\n\n\n\n\n\n\n\n\nConstants\n\n\n\n\n\n\n\n\nName\n\n\nCode\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ngc_file_mapping_regex\n\n\ngc_file_mapping_regex        constant varchar2(100) := '/((\\w+).)?(\\w+).(\\w{3})$';\n\n\n\n\n\n\n\n\ngc_regex_owner_subexpression\n\n\ngc_regex_owner_subexpression constant positive := 2;\n\n\n\n\n\n\n\n\ngc_regex_name_subexpression\n\n\ngc_regex_name_subexpression  constant positive := 3;\n\n\n\n\n\n\n\n\ngc_regex_type_subexpression\n\n\ngc_regex_type_subexpression  constant positive := 4;\n\n\n\n\n\n\n\n\n\n\nTO_HASH_TABLE Function\n\n\n\n\nPrivate functions\n\n\n\n\n\nSyntax\n\n\nfunction to_hash_table(a_key_value_tab ut_key_value_pairs) return tt_key_values\n\n\n\n\nDEFAULT_FILE_TO_OBJ_TYPE_MAP Function\n\n\n\n\nPublic functions\n\n\n\n\n\nSyntax\n\n\nfunction default_file_to_obj_type_map return ut_key_value_pairs", 
            "title": "UT_FILE_MAPPER"
        }, 
        {
            "location": "/ut_file_mapper/#ut_file_mapper", 
            "text": "Data Types    Constants    TO_HASH_TABLE Function   DEFAULT_FILE_TO_OBJ_TYPE_MAP Function", 
            "title": "UT_FILE_MAPPER"
        }, 
        {
            "location": "/ut_file_mapper/#types", 
            "text": "Name  Code  Description      tt_key_values  type tt_key_values is table of varchar2(4000) index by varchar2(4000);", 
            "title": "Types"
        }, 
        {
            "location": "/ut_file_mapper/#constants", 
            "text": "Name  Code  Description      gc_file_mapping_regex  gc_file_mapping_regex        constant varchar2(100) := '/((\\w+).)?(\\w+).(\\w{3})$';     gc_regex_owner_subexpression  gc_regex_owner_subexpression constant positive := 2;     gc_regex_name_subexpression  gc_regex_name_subexpression  constant positive := 3;     gc_regex_type_subexpression  gc_regex_type_subexpression  constant positive := 4;", 
            "title": "Constants"
        }, 
        {
            "location": "/ut_file_mapper/#to_hash_table-function", 
            "text": "Private functions", 
            "title": "TO_HASH_TABLE Function"
        }, 
        {
            "location": "/ut_file_mapper/#syntax", 
            "text": "function to_hash_table(a_key_value_tab ut_key_value_pairs) return tt_key_values", 
            "title": "Syntax"
        }, 
        {
            "location": "/ut_file_mapper/#default_file_to_obj_type_map-function", 
            "text": "Public functions", 
            "title": "DEFAULT_FILE_TO_OBJ_TYPE_MAP Function"
        }, 
        {
            "location": "/ut_file_mapper/#syntax_1", 
            "text": "function default_file_to_obj_type_map return ut_key_value_pairs", 
            "title": "Syntax"
        }, 
        {
            "location": "/ut_metadata/", 
            "text": "UT_METADATA\n\n\n\n\n\n\nData Types\n\n\n\n\n\n\nVariables\n\n\n\n\n\n\nExceptions\n\n\n\n\n\n\nFORM_NAME Function\n\n\n\n\nPACKAGE_VALID Function\n\n\nPROCEDURE_EXISTS Function\n\n\nDO_RESOLVE Procedure\n\n\nDO_RESOLVE-1 Procedure\n\n\nGET_SOURCE_DEFINITION_LINE Function\n\n\nRESET_SOURCE_DEFINITION_CACHE Procedure\n\n\nGET_DBA_VIEW Function\n\n\nPACKAGE_EXISTS_IN_CUR_SCHEMA Function\n\n\n\n\nTypes\n\n\n\n\n\n\n\n\nName\n\n\nCode\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nt_cache\n\n\ntype t_cache is table of all_source.text%type;\n\n\n\n\n\n\n\n\n\n\nVariables\n\n\n\n\n\n\n\n\nName\n\n\nCode\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nend\n\n\n    end if;\n\n\n\n\n\n\n\n\nend\n\n\n    end if;\n\n\n\n\n\n\n\n\nreturn\n\n\n    return l_line;\n\n\n\n\n\n\n\n\n\n\n    g_cached_object := null;\n\n\n\n\n\n\n\n\nl_result\n\n\n    l_result              varchar2(128) := lower(a_dba_view_name);\n\n\n\n\n\n\n\n\npragma\n\n\n    pragma exception_init(l_invalid_object_name,-44002);\n\n\n\n\n\n\n\n\nbegin\n\n\n  begin\n    l_result := dbms_assert.sql_object_name(l_result);\n\n\n\n\n\n\n\n\nreturn\n\n\n    return l_result;\n\n\n\n\n\n\n\n\nc_current_schema\n\n\n    c_current_schema constant all_tables.owner%type := sys_context('USERENV','CURRENT_SCHEMA');\n\n\n\n\n\n\n\n\nreturn\n\n\n    return l_cnt \n 0;\n\n\n\n\n\n\n\n\n\n\nExceptions\n\n\n\n\n\n\n\n\nName\n\n\nCode\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nend\n\n\n    end if;\n\n\n\n\n\n\n\n\nend\n\n\n    end if;\n\n\n\n\n\n\n\n\nreturn\n\n\n    return l_line;\n\n\n\n\n\n\n\n\n\n\n    g_cached_object := null;\n\n\n\n\n\n\n\n\nl_result\n\n\n    l_result              varchar2(128) := lower(a_dba_view_name);\n\n\n\n\n\n\n\n\npragma\n\n\n    pragma exception_init(l_invalid_object_name,-44002);\n\n\n\n\n\n\n\n\nbegin\n\n\n  begin\n    l_result := dbms_assert.sql_object_name(l_result);\n\n\n\n\n\n\n\n\nreturn\n\n\n    return l_result;\n\n\n\n\n\n\n\n\nc_current_schema\n\n\n    c_current_schema constant all_tables.owner%type := sys_context('USERENV','CURRENT_SCHEMA');\n\n\n\n\n\n\n\n\nreturn\n\n\n    return l_cnt \n 0;\n\n\n\n\n\n\n\n\n\n\nFORM_NAME Function\n\n\n\n\nForms correct object/subprogram name to call as owner.object[.subprogram]\n\n\n\n\n\nSyntax\n\n\nfunction form_name(a_owner_name varchar2, a_object varchar2, a_subprogram varchar2 default null) return varchar2\n\n\n\n\nPACKAGE_VALID Function\n\n\n\n\nCheck if package exists and is in a VALID state\n\n\n\n\n\nSyntax\n\n\nfunction package_valid(a_owner_name varchar2, a_package_name in varchar2) return boolean\n\n\n\n\nPROCEDURE_EXISTS Function\n\n\n\n\nCheck if package exists and is VALID and contains the given procedure.\n\n\n\n\n\nSyntax\n\n\nfunction procedure_exists(a_owner_name varchar2, a_package_name in varchar2, a_procedure_name in varchar2)\n  return boolean\n\n\n\n\nDO_RESOLVE Procedure\n\n\n\n\nResolves [owner.]object using dbms_utility.name_resolve and returns resolved parts\n\n\n\n\n\nSyntax\n\n\nprocedure do_resolve(a_owner in out nocopy varchar2, a_object in out nocopy varchar2)\n\n\n\n\nDO_RESOLVE-1 Procedure\n\n\n\n\nResolves [owner.]object[.procedure] using dbms_utility.name_resolve and returns resolved parts\n\n\n\n\n\nSyntax\n\n\nprocedure do_resolve(a_owner in out nocopy varchar2, a_object in out nocopy varchar2, a_procedure_name in out nocopy varchar2)\n\n\n\n\nGET_SOURCE_DEFINITION_LINE Function\n\n\n\n\nReturn the text of the source line for a given object (body). It excludes package spec and type spec\n\n\n\n\n\nSyntax\n\n\nfunction get_source_definition_line(a_owner varchar2, a_object_name varchar2, a_line_no integer) return varchar2\n\n\n\n\nRESET_SOURCE_DEFINITION_CACHE Procedure\n\n\n\n\nInvalidates package-level cache for source.\nCaching is used to improve performance of function get_source_definition_line\n\n\n\n\n\nSyntax\n\n\nprocedure reset_source_definition_cache\n\n\n\n\nGET_DBA_VIEW Function\n\n\n\n\nReturns dba_... view name if it is accessible, otherwise it returns all_xxx view\n\n\n\n\n\nSyntax\n\n\nfunction get_dba_view(a_dba_view_name varchar2) return varchar2\n\n\n\n\nParameters\n\n\n\n\n\n\n\n\nName\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\na_dba_view_name\n\n\nthe name of dba view requested\n\n\n\n\n\n\n\n\nPACKAGE_EXISTS_IN_CUR_SCHEMA Function\n\n\n\n\nReturns true if given object is a package and it exists in current schema\n\n\n\n\n\nSyntax\n\n\nfunction package_exists_in_cur_schema(a_object_name varchar2) return boolean\n\n\n\n\nParameters\n\n\n\n\n\n\n\n\nName\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\na_object_name\n\n\nthe name of the object to be checked", 
            "title": "UT_METADATA"
        }, 
        {
            "location": "/ut_metadata/#ut_metadata", 
            "text": "Data Types    Variables    Exceptions    FORM_NAME Function   PACKAGE_VALID Function  PROCEDURE_EXISTS Function  DO_RESOLVE Procedure  DO_RESOLVE-1 Procedure  GET_SOURCE_DEFINITION_LINE Function  RESET_SOURCE_DEFINITION_CACHE Procedure  GET_DBA_VIEW Function  PACKAGE_EXISTS_IN_CUR_SCHEMA Function", 
            "title": "UT_METADATA"
        }, 
        {
            "location": "/ut_metadata/#types", 
            "text": "Name  Code  Description      t_cache  type t_cache is table of all_source.text%type;", 
            "title": "Types"
        }, 
        {
            "location": "/ut_metadata/#variables", 
            "text": "Name  Code  Description      end      end if;     end      end if;     return      return l_line;          g_cached_object := null;     l_result      l_result              varchar2(128) := lower(a_dba_view_name);     pragma      pragma exception_init(l_invalid_object_name,-44002);     begin    begin     l_result := dbms_assert.sql_object_name(l_result);     return      return l_result;     c_current_schema      c_current_schema constant all_tables.owner%type := sys_context('USERENV','CURRENT_SCHEMA');     return      return l_cnt   0;", 
            "title": "Variables"
        }, 
        {
            "location": "/ut_metadata/#exceptions", 
            "text": "Name  Code  Description      end      end if;     end      end if;     return      return l_line;          g_cached_object := null;     l_result      l_result              varchar2(128) := lower(a_dba_view_name);     pragma      pragma exception_init(l_invalid_object_name,-44002);     begin    begin     l_result := dbms_assert.sql_object_name(l_result);     return      return l_result;     c_current_schema      c_current_schema constant all_tables.owner%type := sys_context('USERENV','CURRENT_SCHEMA');     return      return l_cnt   0;", 
            "title": "Exceptions"
        }, 
        {
            "location": "/ut_metadata/#form_name-function", 
            "text": "Forms correct object/subprogram name to call as owner.object[.subprogram]", 
            "title": "FORM_NAME Function"
        }, 
        {
            "location": "/ut_metadata/#syntax", 
            "text": "function form_name(a_owner_name varchar2, a_object varchar2, a_subprogram varchar2 default null) return varchar2", 
            "title": "Syntax"
        }, 
        {
            "location": "/ut_metadata/#package_valid-function", 
            "text": "Check if package exists and is in a VALID state", 
            "title": "PACKAGE_VALID Function"
        }, 
        {
            "location": "/ut_metadata/#syntax_1", 
            "text": "function package_valid(a_owner_name varchar2, a_package_name in varchar2) return boolean", 
            "title": "Syntax"
        }, 
        {
            "location": "/ut_metadata/#procedure_exists-function", 
            "text": "Check if package exists and is VALID and contains the given procedure.", 
            "title": "PROCEDURE_EXISTS Function"
        }, 
        {
            "location": "/ut_metadata/#syntax_2", 
            "text": "function procedure_exists(a_owner_name varchar2, a_package_name in varchar2, a_procedure_name in varchar2)\n  return boolean", 
            "title": "Syntax"
        }, 
        {
            "location": "/ut_metadata/#do_resolve-procedure", 
            "text": "Resolves [owner.]object using dbms_utility.name_resolve and returns resolved parts", 
            "title": "DO_RESOLVE Procedure"
        }, 
        {
            "location": "/ut_metadata/#syntax_3", 
            "text": "procedure do_resolve(a_owner in out nocopy varchar2, a_object in out nocopy varchar2)", 
            "title": "Syntax"
        }, 
        {
            "location": "/ut_metadata/#do_resolve-1-procedure", 
            "text": "Resolves [owner.]object[.procedure] using dbms_utility.name_resolve and returns resolved parts", 
            "title": "DO_RESOLVE-1 Procedure"
        }, 
        {
            "location": "/ut_metadata/#syntax_4", 
            "text": "procedure do_resolve(a_owner in out nocopy varchar2, a_object in out nocopy varchar2, a_procedure_name in out nocopy varchar2)", 
            "title": "Syntax"
        }, 
        {
            "location": "/ut_metadata/#get_source_definition_line-function", 
            "text": "Return the text of the source line for a given object (body). It excludes package spec and type spec", 
            "title": "GET_SOURCE_DEFINITION_LINE Function"
        }, 
        {
            "location": "/ut_metadata/#syntax_5", 
            "text": "function get_source_definition_line(a_owner varchar2, a_object_name varchar2, a_line_no integer) return varchar2", 
            "title": "Syntax"
        }, 
        {
            "location": "/ut_metadata/#reset_source_definition_cache-procedure", 
            "text": "Invalidates package-level cache for source. Caching is used to improve performance of function get_source_definition_line", 
            "title": "RESET_SOURCE_DEFINITION_CACHE Procedure"
        }, 
        {
            "location": "/ut_metadata/#syntax_6", 
            "text": "procedure reset_source_definition_cache", 
            "title": "Syntax"
        }, 
        {
            "location": "/ut_metadata/#get_dba_view-function", 
            "text": "Returns dba_... view name if it is accessible, otherwise it returns all_xxx view", 
            "title": "GET_DBA_VIEW Function"
        }, 
        {
            "location": "/ut_metadata/#syntax_7", 
            "text": "function get_dba_view(a_dba_view_name varchar2) return varchar2", 
            "title": "Syntax"
        }, 
        {
            "location": "/ut_metadata/#parameters", 
            "text": "Name  Description      a_dba_view_name  the name of dba view requested", 
            "title": "Parameters"
        }, 
        {
            "location": "/ut_metadata/#package_exists_in_cur_schema-function", 
            "text": "Returns true if given object is a package and it exists in current schema", 
            "title": "PACKAGE_EXISTS_IN_CUR_SCHEMA Function"
        }, 
        {
            "location": "/ut_metadata/#syntax_8", 
            "text": "function package_exists_in_cur_schema(a_object_name varchar2) return boolean", 
            "title": "Syntax"
        }, 
        {
            "location": "/ut_metadata/#parameters_1", 
            "text": "Name  Description      a_object_name  the name of the object to be checked", 
            "title": "Parameters"
        }, 
        {
            "location": "/ut_runner/", 
            "text": "UT_RUNNER\n\n\n\n\nTO_UT_OBJECT_LIST Function\n\n\nVERSION Function\n\n\nVERSION_COMPATIBILITY_CHECK Function\n\n\nRUN Procedure\n\n\nREBUILD_ANNOTATION_CACHE Procedure\n\n\nPURGE_CACHE Procedure\n\n\nGET_UNIT_TEST_INFO Function\n\n\nGET_REPORTERS_LIST Function\n\n\n\n\nTO_UT_OBJECT_LIST Function\n\n\n\n\nPrivate functions\n\n\n\n\n\nSyntax\n\n\nfunction to_ut_object_list(a_names ut_varchar2_list, a_schema_names ut_varchar2_rows) return ut_object_names\n\n\n\n\nVERSION Function\n\n\n\n\nPublic functions\n\n\n\n\n\nSyntax\n\n\nfunction version return varchar2\n\n\n\n\nVERSION_COMPATIBILITY_CHECK Function\n\n\n\n\nCheck if version is compatible with another version (by default the current framework version)\nVersion is compatible if:\n  a_current.major = a_requested.major\n  a_requested.minor \n a_current.minor or a_requested.minor = a_current.minor and a_requested.bugfix \n= a_current.bugfix\n\n\n\n\n\nSyntax\n\n\nfunction version_compatibility_check( a_requested varchar2, a_current varchar2 := null ) return integer\n\n\n\n\nParameters\n\n\n\n\n\n\n\n\nName\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\na_requested\n\n\nrequested utPLSQL version string\n\n\n\n\n\n\na_current\n\n\ncurrent utPLSQL version string, if null is passed, defaults to current framework version\n\n\n\n\n\n\nreturn\n\n\n1/0         1-true, 0-false\n\n\n\n\n\n\n\n\nRUN Procedure\n\n\n\n\nExecute specified suites/tests by paths\n\n\n\n\n\nSyntax\n\n\nprocedure run(\n  a_paths ut_varchar2_list,\n  a_reporters ut_reporters,\n  a_color_console boolean := false,\n  a_coverage_schemes ut_varchar2_list := null,\n  a_source_file_mappings ut_file_mappings := null,\n  a_test_file_mappings ut_file_mappings := null,\n  a_include_objects ut_varchar2_list := null,\n  a_exclude_objects ut_varchar2_list := null,\n  a_fail_on_errors boolean := false,\n  a_client_character_set varchar2 := null\n)\n\n\n\n\nParameters\n\n\n\n\n\n\n\n\nName\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\na_paths\n\n\nlist of schemes, packages, procedures or suite-paths to execute\n\n\n\n\n\n\na_reporters\n\n\nlist of reporter objects (formats) to use for reporting\n\n\n\n\n\n\na_color_console\n\n\ntrue/false - should the console format reporters use ANSI color tags\n\n\n\n\n\n\na_coverage_schemes\n\n\nlist of database schemes to include in coverage\n\n\n\n\n\n\na_source_file_mappings\n\n\nlist of project source files mapped to DB objects that coverage should be reported on\n\n\n\n\n\n\na_test_file_mappings\n\n\nlist of project test files mapped to DB objects that test results should be reported on\n\n\n\n\n\n\na_include_objects\n\n\nlist of database objects (in format \nowner.name\n) that coverage should be reported on\n\n\n\n\n\n\na_exclude_objects\n\n\nlist of database objects (in format \nowner.name\n) that coverage should be skipped for\n\n\n\n\n\n\na_fail_on_errors\n\n\ntrue/false - should an exception be thrown when tests are completed with failures/errors\n\n\n\n\n\n\n\n\nExample\n\n\nParameter `a_paths` accepts values of the following formats:\n  schema - executes all suites in the schema\n  schema:suite1[.suite2] - executes all items of suite1 (suite2) in the schema.\n                         suite1.suite2 is a suitepath variable\n  schema:suite1[.suite2][.test1] - executes test1 in suite suite1.suite2\n  schema.suite1 - executes the suite package suite1 in the schema \nschema\n\n                all the parent suites in the hiearcy setups/teardown procedures as also executed\n                all chile items are executed\n  schema.suite1.test2 - executes test2 procedure of suite1 suite with execution of all parent setup/teardown procedures\n\n\n\n\nREBUILD_ANNOTATION_CACHE Procedure\n\n\n\n\nRebuilds annotation cache for a specified schema and object type.\n It can be used to speedup execution of utPLSQL on a given schema\n  if it is executed before initial call made to \nut.run\n or \nut_runner.run\n procedure.\n\n\n\n\n\nSyntax\n\n\nprocedure rebuild_annotation_cache(a_object_owner varchar2, a_object_type varchar2 := null)\n\n\n\n\nParameters\n\n\n\n\n\n\n\n\nName\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\na_object_owner\n\n\nowner of objects to get annotations for\n\n\n\n\n\n\na_object_type\n\n\noptional type of objects to get annotations for (defaults to \nPACKAGE\n)\n\n\n\n\n\n\n\n\nPURGE_CACHE Procedure\n\n\n\n\nRemoves cached information about annotations for objects of specified type and specified owner\n\n\n\n\n\nSyntax\n\n\nprocedure purge_cache(a_object_owner varchar2 := null, a_object_type varchar2 := null)\n\n\n\n\nParameters\n\n\n\n\n\n\n\n\nName\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\na_object_owner\n\n\noptional - owner of objects to purge annotations for. If null (default) then all schemas are purged\n\n\n\n\n\n\na_object_type\n\n\noptional - type of objects to purge annotations for. If null (default) then cache for all object types is purged\n\n\n\n\n\n\n\n\nGET_UNIT_TEST_INFO Function\n\n\n\n\nReturns a pipelined collection containing information about unit tests package/packages for a given owner\n\n\n\n\n\nSyntax\n\n\nfunction get_unit_test_info(a_owner varchar2, a_package_name varchar2 := null) return tt_annotations pipelined\n\n\n\n\nParameters\n\n\n\n\n\n\n\n\nName\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\na_owner\n\n\nowner of unit tests to retrieve\n\n\n\n\n\n\na_package_name\n\n\noptional name of unit test package to retrieve, if NULLm all unit test packages are returned\n\n\n\n\n\n\nreturn\n\n\ntt_annotations table of records\n\n\n\n\n\n\n\n\nGET_REPORTERS_LIST Function\n\n\n\n\nReturns a list of available reporters. Gives information about whether a reporter is an output reporter or not\n\n\n\n\n\nSyntax\n\n\nfunction get_reporters_list return tt_reporters_info pipelined\n\n\n\n\nParameters\n\n\n\n\n\n\n\n\nName\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nreturn\n\n\ntt_reporters_info", 
            "title": "UT_RUNNER"
        }, 
        {
            "location": "/ut_runner/#ut_runner", 
            "text": "TO_UT_OBJECT_LIST Function  VERSION Function  VERSION_COMPATIBILITY_CHECK Function  RUN Procedure  REBUILD_ANNOTATION_CACHE Procedure  PURGE_CACHE Procedure  GET_UNIT_TEST_INFO Function  GET_REPORTERS_LIST Function", 
            "title": "UT_RUNNER"
        }, 
        {
            "location": "/ut_runner/#to_ut_object_list-function", 
            "text": "Private functions", 
            "title": "TO_UT_OBJECT_LIST Function"
        }, 
        {
            "location": "/ut_runner/#syntax", 
            "text": "function to_ut_object_list(a_names ut_varchar2_list, a_schema_names ut_varchar2_rows) return ut_object_names", 
            "title": "Syntax"
        }, 
        {
            "location": "/ut_runner/#version-function", 
            "text": "Public functions", 
            "title": "VERSION Function"
        }, 
        {
            "location": "/ut_runner/#syntax_1", 
            "text": "function version return varchar2", 
            "title": "Syntax"
        }, 
        {
            "location": "/ut_runner/#version_compatibility_check-function", 
            "text": "Check if version is compatible with another version (by default the current framework version) Version is compatible if:   a_current.major = a_requested.major   a_requested.minor   a_current.minor or a_requested.minor = a_current.minor and a_requested.bugfix  = a_current.bugfix", 
            "title": "VERSION_COMPATIBILITY_CHECK Function"
        }, 
        {
            "location": "/ut_runner/#syntax_2", 
            "text": "function version_compatibility_check( a_requested varchar2, a_current varchar2 := null ) return integer", 
            "title": "Syntax"
        }, 
        {
            "location": "/ut_runner/#parameters", 
            "text": "Name  Description      a_requested  requested utPLSQL version string    a_current  current utPLSQL version string, if null is passed, defaults to current framework version    return  1/0         1-true, 0-false", 
            "title": "Parameters"
        }, 
        {
            "location": "/ut_runner/#run-procedure", 
            "text": "Execute specified suites/tests by paths", 
            "title": "RUN Procedure"
        }, 
        {
            "location": "/ut_runner/#syntax_3", 
            "text": "procedure run(\n  a_paths ut_varchar2_list,\n  a_reporters ut_reporters,\n  a_color_console boolean := false,\n  a_coverage_schemes ut_varchar2_list := null,\n  a_source_file_mappings ut_file_mappings := null,\n  a_test_file_mappings ut_file_mappings := null,\n  a_include_objects ut_varchar2_list := null,\n  a_exclude_objects ut_varchar2_list := null,\n  a_fail_on_errors boolean := false,\n  a_client_character_set varchar2 := null\n)", 
            "title": "Syntax"
        }, 
        {
            "location": "/ut_runner/#parameters_1", 
            "text": "Name  Description      a_paths  list of schemes, packages, procedures or suite-paths to execute    a_reporters  list of reporter objects (formats) to use for reporting    a_color_console  true/false - should the console format reporters use ANSI color tags    a_coverage_schemes  list of database schemes to include in coverage    a_source_file_mappings  list of project source files mapped to DB objects that coverage should be reported on    a_test_file_mappings  list of project test files mapped to DB objects that test results should be reported on    a_include_objects  list of database objects (in format  owner.name ) that coverage should be reported on    a_exclude_objects  list of database objects (in format  owner.name ) that coverage should be skipped for    a_fail_on_errors  true/false - should an exception be thrown when tests are completed with failures/errors", 
            "title": "Parameters"
        }, 
        {
            "location": "/ut_runner/#example", 
            "text": "Parameter `a_paths` accepts values of the following formats:\n  schema - executes all suites in the schema\n  schema:suite1[.suite2] - executes all items of suite1 (suite2) in the schema.\n                         suite1.suite2 is a suitepath variable\n  schema:suite1[.suite2][.test1] - executes test1 in suite suite1.suite2\n  schema.suite1 - executes the suite package suite1 in the schema  schema \n                all the parent suites in the hiearcy setups/teardown procedures as also executed\n                all chile items are executed\n  schema.suite1.test2 - executes test2 procedure of suite1 suite with execution of all parent setup/teardown procedures", 
            "title": "Example"
        }, 
        {
            "location": "/ut_runner/#rebuild_annotation_cache-procedure", 
            "text": "Rebuilds annotation cache for a specified schema and object type.  It can be used to speedup execution of utPLSQL on a given schema   if it is executed before initial call made to  ut.run  or  ut_runner.run  procedure.", 
            "title": "REBUILD_ANNOTATION_CACHE Procedure"
        }, 
        {
            "location": "/ut_runner/#syntax_4", 
            "text": "procedure rebuild_annotation_cache(a_object_owner varchar2, a_object_type varchar2 := null)", 
            "title": "Syntax"
        }, 
        {
            "location": "/ut_runner/#parameters_2", 
            "text": "Name  Description      a_object_owner  owner of objects to get annotations for    a_object_type  optional type of objects to get annotations for (defaults to  PACKAGE )", 
            "title": "Parameters"
        }, 
        {
            "location": "/ut_runner/#purge_cache-procedure", 
            "text": "Removes cached information about annotations for objects of specified type and specified owner", 
            "title": "PURGE_CACHE Procedure"
        }, 
        {
            "location": "/ut_runner/#syntax_5", 
            "text": "procedure purge_cache(a_object_owner varchar2 := null, a_object_type varchar2 := null)", 
            "title": "Syntax"
        }, 
        {
            "location": "/ut_runner/#parameters_3", 
            "text": "Name  Description      a_object_owner  optional - owner of objects to purge annotations for. If null (default) then all schemas are purged    a_object_type  optional - type of objects to purge annotations for. If null (default) then cache for all object types is purged", 
            "title": "Parameters"
        }, 
        {
            "location": "/ut_runner/#get_unit_test_info-function", 
            "text": "Returns a pipelined collection containing information about unit tests package/packages for a given owner", 
            "title": "GET_UNIT_TEST_INFO Function"
        }, 
        {
            "location": "/ut_runner/#syntax_6", 
            "text": "function get_unit_test_info(a_owner varchar2, a_package_name varchar2 := null) return tt_annotations pipelined", 
            "title": "Syntax"
        }, 
        {
            "location": "/ut_runner/#parameters_4", 
            "text": "Name  Description      a_owner  owner of unit tests to retrieve    a_package_name  optional name of unit test package to retrieve, if NULLm all unit test packages are returned    return  tt_annotations table of records", 
            "title": "Parameters"
        }, 
        {
            "location": "/ut_runner/#get_reporters_list-function", 
            "text": "Returns a list of available reporters. Gives information about whether a reporter is an output reporter or not", 
            "title": "GET_REPORTERS_LIST Function"
        }, 
        {
            "location": "/ut_runner/#syntax_7", 
            "text": "function get_reporters_list return tt_reporters_info pipelined", 
            "title": "Syntax"
        }, 
        {
            "location": "/ut_runner/#parameters_5", 
            "text": "Name  Description      return  tt_reporters_info", 
            "title": "Parameters"
        }, 
        {
            "location": "/ut_suite_builder/", 
            "text": "UT_SUITE_BUILDER\n\n\n\n\n\n\nData Types\n\n\n\n\n\n\nVariables\n\n\n\n\n\n\nExceptions\n\n\n\n\n\n\nBUILD_SCHEMA_SUITES Function\n\n\n\n\nBUILD_SUITES Function\n\n\n\n\nTypes\n\n\n\n\n\n\n\n\nName\n\n\nCode\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nt_annotation_text\n\n\nsubtype t_annotation_text     is varchar2(4000);\n\n\n\n\n\n\n\n\nt_annotation_name\n\n\nsubtype t_annotation_name     is varchar2(4000);\n\n\n\n\n\n\n\n\nt_object_name\n\n\nsubtype t_object_name         is varchar2(500);\n\n\n\n\n\n\n\n\nt_annotation_position\n\n\nsubtype t_annotation_position is binary_integer;\n\n\n\n\n\n\n\n\ntt_executables\n\n\ntype tt_executables is table of ut_executables index by t_annotation_position;\n\n\n\n\n\n\n\n\ntt_tests\n\n\ntype tt_tests is table of ut_test index by t_annotation_position;\n\n\n\n\n\n\n\n\nt_annotation\n\n\ntype t_annotation is record(\n  name                  t_annotation_name,\n  text                  t_annotation_text,\n  procedure_name        t_object_name\n);\n\n\n\n\n\n\n\n\ntt_annotations_by_line\n\n\ntype tt_annotations_by_line is table of t_annotation index by t_annotation_position;\n\n\n\n\n\n\n\n\ntt_annotations_by_name\n\n\ntype tt_annotations_by_name is table of tt_annotation_texts index by t_annotation_name;\n\n\n\n\n\n\n\n\ntt_annotations_by_proc\n\n\ntype tt_annotations_by_proc is table of tt_annotations_by_name index by t_object_name;\n\n\n\n\n\n\n\n\nt_annotations_info\n\n\ntype t_annotations_info is record (\n  owner   t_object_name,\n  name    t_object_name,\n  by_line tt_annotations_by_line,\n  by_proc tt_annotations_by_proc,\n  by_name tt_annotations_by_name\n);\n\n\n\n\n\n\n\n\n\n\nVariables\n\n\n\n\n\n\n\n\nName\n\n\nCode\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n\n\nl_throws_list := ut_utils.trim_list_elements(ut_utils.string_to_table(a_annotation_text, ',', 'Y'));\n\n\n\n\n\n\n\n\nend\n\n\nend if;\n\n\n\n\n\n\n\n\nelse\n\n\nelse\n  l_exception_number_list.extend;\n\n\n\n\n\n\n\n\nend\n\n\nend if;\n\n\n\n\n\n\n\n\n\n\nl_exception_number := null;\n\n\n\n\n\n\n\n\nend\n\n\n      end loop;\n\n\n\n\n\n\n\n\nreturn\n\n\n      return l_exception_number_list;\n\n\n\n\n\n\n\n\nbegin\n\n\n  begin\n    a_list := ut_integer_list();\n\n\n\n\n\n\n\n\n\n\n    l_annotation_pos := a_throws_ann_text.first;\n\n\n\n\n\n\n\n\nend\n\n\n      end if;\n\n\n\n\n\n\n\n\n\n\n      l_annotation_pos := a_throws_ann_text.next(l_annotation_pos);\n\n\n\n\n\n\n\n\nend\n\n\n    end loop;\n\n\n\n\n\n\n\n\nl_pos\n\n\n    l_pos   t_annotation_position := a_list.first;\n\n\n\n\n\n\n\n\n\n\nl_pos := a_list.next(l_pos);\n\n\n\n\n\n\n\n\nend\n\n\n      end loop;\n\n\n\n\n\n\n\n\nreturn\n\n\n      return l_result;\n\n\n\n\n\n\n\n\nl_pos\n\n\n    l_pos   t_annotation_position := a_list.first;\n\n\n\n\n\n\n\n\n\n\nl_pos := a_list.next(l_pos);\n\n\n\n\n\n\n\n\nend\n\n\n      end loop;\n\n\n\n\n\n\n\n\nreturn\n\n\n      return l_result;\n\n\n\n\n\n\n\n\nend\n\n\n      end if;\n\n\n\n\n\n\n\n\nl_result\n\n\n    l_result          tt_executables;\n\n\n\n\n\n\n\n\nl_annotation_pos\n\n\n    l_annotation_pos  binary_integer;\n\n\n\n\n\n\n\n\nl_procedures_list\n\n\n    l_procedures_list ut_varchar2_list;\n\n\n\n\n\n\n\n\nl_procedures_pos\n\n\n    l_procedures_pos  binary_integer;\n\n\n\n\n\n\n\n\nl_components_list\n\n\n    l_components_list ut_varchar2_list;\n\n\n\n\n\n\n\n\nbegin\n\n\n  begin\n    l_annotation_pos := a_annotation_texts.first;\n\n\n\n\n\n\n\n\n\n\n      l_procedures_pos := l_procedures_list.first;\n\n\n\n\n\n\n\n\n\n\n      l_executables := ut_executables();\n\n\n\n\n\n\n\n\n\n\nl_procedures_pos := l_procedures_list.next(l_procedures_pos);\n\n\n\n\n\n\n\n\nend\n\n\n      end loop;\n\n\n\n\n\n\n\n\n\n\n      l_annotation_pos := a_annotation_texts.next(l_annotation_pos);\n\n\n\n\n\n\n\n\nend\n\n\n    end loop;\n\n\n\n\n\n\n\n\nreturn\n\n\n    return l_result;\n\n\n\n\n\n\n\n\nl_line_no\n\n\n    l_line_no           binary_integer;\n\n\n\n\n\n\n\n\n\n\n  l_line_no := a_annotations(a_for_annotation).next( l_line_no );\n\n\n\n\n\n\n\n\nend\n\n\nend loop;\n\n\n\n\n\n\n\n\nend\n\n\n      end if;\n\n\n\n\n\n\n\n\nend\n\n\n    end if;\n\n\n\n\n\n\n\n\nl_warning\n\n\n    l_warning         varchar2(32767);\n\n\n\n\n\n\n\n\nl_line_no\n\n\n    l_line_no           binary_integer;\n\n\n\n\n\n\n\n\n\n\n    l_line_no := a_proc_annotations(l_annotation_name).next(l_line_no);\n\n\n\n\n\n\n\n\nend\n\n\n  end loop;\n\n\n\n\n\n\n\n\nend\n\n\nend if;\n\n\n\n\n\n\n\n\n\n\nl_annotation_name := a_proc_annotations.next(l_annotation_name);\n\n\n\n\n\n\n\n\nend\n\n\n      end loop;\n\n\n\n\n\n\n\n\nend\n\n\n    end if;\n\n\n\n\n\n\n\n\nl_annotation_texts\n\n\n    l_annotation_texts tt_annotation_texts;\n\n\n\n\n\n\n\n\nl_annotation_pos\n\n\n    l_annotation_pos   binary_integer;\n\n\n\n\n\n\n\n\nend\n\n\n    end if;\n\n\n\n\n\n\n\n\n\n\n    \n    l_test := ut_test(a_suite.object_owner, a_suite.object_name, a_procedure_name);\n\n\n\n\n\n\n\n\nelse\n\n\n    else\n      l_test.description := a_proc_annotations(gc_test)(a_proc_annotations(gc_test).first);\n\n\n\n\n\n\n\n\nend\n\n\n    end if;\n\n\n\n\n\n\n\n\nend\n\n\n      end if;\n\n\n\n\n\n\n\n\nend\n\n\n    end if;\n\n\n\n\n\n\n\n\nend\n\n\n    end if;\n\n\n\n\n\n\n\n\nend\n\n\n    end if;\n\n\n\n\n\n\n\n\nend\n\n\n    end if;\n\n\n\n\n\n\n\n\nl_context\n\n\n    l_context   ut_logical_suite;\n\n\n\n\n\n\n\n\nend\n\n\nend if;\n\n\n\n\n\n\n\n\nend\n\n\n      end loop;\n\n\n\n\n\n\n\n\nend\n\n\n    end if;\n\n\n\n\n\n\n\n\nend\n\n\n    end if;\n\n\n\n\n\n\n\n\nl_tests\n\n\n    l_tests            tt_tests;\n\n\n\n\n\n\n\n\nbegin\n\n\n  begin\n    l_procedure_name := a_proc_annotations.first;\n\n\n\n\n\n\n\n\n\n\n      l_procedure_name := a_proc_annotations.next( l_procedure_name );\n\n\n\n\n\n\n\n\nend\n\n\n    end loop;\n\n\n\n\n\n\n\n\nend\n\n\nend if;\n\n\n\n\n\n\n\n\nend\n\n\n      end if;\n\n\n\n\n\n\n\n\nend\n\n\n    end if;\n\n\n\n\n\n\n\n\nl_after_each_list\n\n\n    l_after_each_list    tt_executables;\n\n\n\n\n\n\n\n\nl_before_all_list\n\n\n    l_before_all_list    tt_executables;\n\n\n\n\n\n\n\n\nl_after_all_list\n\n\n    l_after_all_list     tt_executables;\n\n\n\n\n\n\n\n\nl_executables\n\n\n    l_executables        ut_executables;\n\n\n\n\n\n\n\n\nl_rollback_type\n\n\n    l_rollback_type      ut_utils.t_rollback_type;\n\n\n\n\n\n\n\n\nl_annotation_text\n\n\n    l_annotation_text    t_annotation_text;\n\n\n\n\n\n\n\n\nend\n\n\n      end if;\n\n\n\n\n\n\n\n\nend\n\n\n    end if;\n\n\n\n\n\n\n\n\nend\n\n\n      end if;\n\n\n\n\n\n\n\n\nend\n\n\n    end if;\n\n\n\n\n\n\n\n\nend\n\n\n    end if;\n\n\n\n\n\n\n\n\nend\n\n\n    end if;\n\n\n\n\n\n\n\n\nend\n\n\n    end if;\n\n\n\n\n\n\n\n\nend\n\n\n    end if;\n\n\n\n\n\n\n\n\nl_end_context_pos\n\n\n    l_end_context_pos    t_annotation_position;\n\n\n\n\n\n\n\n\nl_context_name\n\n\n    l_context_name       t_object_name;\n\n\n\n\n\n\n\n\nl_ctx_annotations\n\n\n    l_ctx_annotations    t_annotations_info;\n\n\n\n\n\n\n\n\nl_context\n\n\n    l_context            ut_suite_context;\n\n\n\n\n\n\n\n\nl_context_no\n\n\n    l_context_no         binary_integer := 1;\n\n\n\n\n\n\n\n\nend\n\n\nend loop;\n\n\n\n\n\n\n\n\nend\n\n\n      end if;\n\n\n\n\n\n\n\n\nreturn\n\n\n      return l_result;\n\n\n\n\n\n\n\n\nl_position\n\n\n      l_position        t_annotation_position;\n\n\n\n\n\n\n\n\nl_procedure_name\n\n\n      l_procedure_name  t_object_name;\n\n\n\n\n\n\n\n\nl_annotation_name\n\n\n      l_annotation_name t_annotation_name;\n\n\n\n\n\n\n\n\nl_annotation_text\n\n\n      l_annotation_text t_annotation_text;\n\n\n\n\n\n\n\n\nbegin\n\n\n    begin\n      l_position := a_context_pos;\n\n\n\n\n\n\n\n\n\n\nl_procedure_name  := l_result.by_line(l_position).procedure_name;\n\n\n\n\n\n\n\n\n\n\nl_annotation_name := l_result.by_line(l_position).name;\n\n\n\n\n\n\n\n\n\n\nl_annotation_text := l_result.by_line(l_position).text;\n\n\n\n\n\n\n\n\nelse\n\n\nelse\n  l_result.by_name(l_annotation_name)(l_position) := l_annotation_text;\n\n\n\n\n\n\n\n\nend\n\n\nend if;\n\n\n\n\n\n\n\n\n\n\nl_position := a_annotations.by_line.next(l_position);\n\n\n\n\n\n\n\n\nend\n\n\n      end loop;\n\n\n\n\n\n\n\n\nreturn\n\n\n      return l_result;\n\n\n\n\n\n\n\n\nend\n\n\n    end if;\n\n\n\n\n\n\n\n\n\n\n    l_context_pos := a_annotations.by_name( gc_context).first;\n\n\n\n\n\n\n\n\nend\n\n\n      end if;\n\n\n\n\n\n\n\n\n\n\n      l_ctx_annotations   := get_annotations_in_context( a_annotations, l_context_pos, l_end_context_pos);\n\n\n\n\n\n\n\n\n\n\n      l_context := ut_suite_context(a_suite.object_owner, a_suite.object_name, l_context_name );\n\n\n\n\n\n\n\n\nexit\n\n\n      exit when not a_annotations.by_name.exists( gc_context);\n\n\n\n\n\n\n\n\n\n\n      l_context_pos := a_annotations.by_name( gc_context).next( l_context_pos);\n\n\n\n\n\n\n\n\n\n\n      l_context_no := l_context_no + 1;\n\n\n\n\n\n\n\n\nend\n\n\n    end loop;\n\n\n\n\n\n\n\n\n\n\nl_annotation_pos := a_package_ann_index(gc_context).next(l_annotation_pos);\n\n\n\n\n\n\n\n\nend\n\n\n      end loop;\n\n\n\n\n\n\n\n\nend\n\n\n    end if;\n\n\n\n\n\n\n\n\n\n\nl_annotation_pos := a_package_ann_index(gc_endcontext).next(l_annotation_pos);\n\n\n\n\n\n\n\n\nend\n\n\n      end loop;\n\n\n\n\n\n\n\n\nend\n\n\n    end if;\n\n\n\n\n\n\n\n\nl_annotation_pos\n\n\n    l_annotation_pos t_annotation_position;\n\n\n\n\n\n\n\n\nl_suite\n\n\n    l_suite          ut_suite;\n\n\n\n\n\n\n\n\n\n\n      l_annotation_pos := l_annotations.by_name( gc_suite).first;\n\n\n\n\n\n\n\n\nend\n\n\n    end if;\n\n\n\n\n\n\n\n\nreturn\n\n\n    return l_suite;\n\n\n\n\n\n\n\n\nl_suite_path\n\n\n    l_suite_path        varchar2(4000 char);\n\n\n\n\n\n\n\n\nl_parent_path\n\n\n    l_parent_path       varchar2(4000 char);\n\n\n\n\n\n\n\n\nl_name\n\n\n    l_name              varchar2(4000 char);\n\n\n\n\n\n\n\n\nl_suites_by_path\n\n\n    l_suites_by_path    tt_schema_suites;\n\n\n\n\n\n\n\n\nbegin\n\n\n  begin\n    l_suites_by_path := a_suites_by_path;\n\n\n\n\n\n\n\n\n\n\n    l_suite_path  := l_suites_by_path.last;\n\n\n\n\n\n\n\n\nelse\n\n\nelse\n  ut_utils.debug_log('  Parent suite \"'\n\n\n\n\n\n\n\n\nend\n\n\nend if;\n\n\n\n\n\n\n\n\nend\n\n\n      end if;\n\n\n\n\n\n\n\n\n\n\n      l_suite_path := l_suites_by_path.prior(l_suite_path);\n\n\n\n\n\n\n\n\nend\n\n\n    end loop;\n\n\n\n\n\n\n\n\nreturn\n\n\n    return l_result;\n\n\n\n\n\n\n\n\nl_annotated_objects\n\n\n    l_annotated_objects ut_annotated_objects;\n\n\n\n\n\n\n\n\nl_all_suites\n\n\n    l_all_suites        tt_schema_suites;\n\n\n\n\n\n\n\n\nl_result\n\n\n    l_result            t_schema_suites_info;\n\n\n\n\n\n\n\n\nl_annotation\n\n\n      l_annotation      t_annotation;\n\n\n\n\n\n\n\n\nl_annotation_no\n\n\n      l_annotation_no   binary_integer;\n\n\n\n\n\n\n\n\nl_annotation_pos\n\n\n      l_annotation_pos  binary_integer;\n\n\n\n\n\n\n\n\nbegin\n\n\n    begin\n      l_result.owner := a_object.object_owner;\n\n\n\n\n\n\n\n\n\n\n      l_annotation_no := a_object.annotations.first;\n\n\n\n\n\n\n\n\nelse\n\n\nelse\n  l_result.by_proc(l_annotation.procedure_name)(l_annotation.name)(l_annotation_pos) := l_annotation.text;\n\n\n\n\n\n\n\n\nend\n\n\nend if;\n\n\n\n\n\n\n\n\n\n\nl_annotation_no := a_object.annotations.next(l_annotation_no);\n\n\n\n\n\n\n\n\nend\n\n\n      end loop;\n\n\n\n\n\n\n\n\nreturn\n\n\n      return l_result;\n\n\n\n\n\n\n\n\nbegin\n\n\n  begin\n    fetch a_annotated_objects bulk collect into l_annotated_objects;\n\n\n\n\n\n\n\n\nclose\n\n\n    close a_annotated_objects;\n\n\n\n\n\n\n\n\nend\n\n\n      end if;\n\n\n\n\n\n\n\n\nend\n\n\n    end loop;\n\n\n\n\n\n\n\n\nreturn\n\n\n    return l_result;\n\n\n\n\n\n\n\n\nreturn\n\n\n    return build_suites(l_annotations_cursor);\n\n\n\n\n\n\n\n\nend\n\n\nend ut_suite_builder;\n\n\n\n\n\n\n\n\n\n\nExceptions\n\n\n\n\n\n\n\n\nName\n\n\nCode\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n\n\nl_throws_list := ut_utils.trim_list_elements(ut_utils.string_to_table(a_annotation_text, ',', 'Y'));\n\n\n\n\n\n\n\n\nend\n\n\nend if;\n\n\n\n\n\n\n\n\nelse\n\n\nelse\n  l_exception_number_list.extend;\n\n\n\n\n\n\n\n\nend\n\n\nend if;\n\n\n\n\n\n\n\n\n\n\nl_exception_number := null;\n\n\n\n\n\n\n\n\nend\n\n\n      end loop;\n\n\n\n\n\n\n\n\nreturn\n\n\n      return l_exception_number_list;\n\n\n\n\n\n\n\n\nbegin\n\n\n  begin\n    a_list := ut_integer_list();\n\n\n\n\n\n\n\n\n\n\n    l_annotation_pos := a_throws_ann_text.first;\n\n\n\n\n\n\n\n\nend\n\n\n      end if;\n\n\n\n\n\n\n\n\n\n\n      l_annotation_pos := a_throws_ann_text.next(l_annotation_pos);\n\n\n\n\n\n\n\n\nend\n\n\n    end loop;\n\n\n\n\n\n\n\n\nl_pos\n\n\n    l_pos   t_annotation_position := a_list.first;\n\n\n\n\n\n\n\n\n\n\nl_pos := a_list.next(l_pos);\n\n\n\n\n\n\n\n\nend\n\n\n      end loop;\n\n\n\n\n\n\n\n\nreturn\n\n\n      return l_result;\n\n\n\n\n\n\n\n\nl_pos\n\n\n    l_pos   t_annotation_position := a_list.first;\n\n\n\n\n\n\n\n\n\n\nl_pos := a_list.next(l_pos);\n\n\n\n\n\n\n\n\nend\n\n\n      end loop;\n\n\n\n\n\n\n\n\nreturn\n\n\n      return l_result;\n\n\n\n\n\n\n\n\nend\n\n\n      end if;\n\n\n\n\n\n\n\n\nl_result\n\n\n    l_result          tt_executables;\n\n\n\n\n\n\n\n\nl_annotation_pos\n\n\n    l_annotation_pos  binary_integer;\n\n\n\n\n\n\n\n\nl_procedures_list\n\n\n    l_procedures_list ut_varchar2_list;\n\n\n\n\n\n\n\n\nl_procedures_pos\n\n\n    l_procedures_pos  binary_integer;\n\n\n\n\n\n\n\n\nl_components_list\n\n\n    l_components_list ut_varchar2_list;\n\n\n\n\n\n\n\n\nbegin\n\n\n  begin\n    l_annotation_pos := a_annotation_texts.first;\n\n\n\n\n\n\n\n\n\n\n      l_procedures_pos := l_procedures_list.first;\n\n\n\n\n\n\n\n\n\n\n      l_executables := ut_executables();\n\n\n\n\n\n\n\n\n\n\nl_procedures_pos := l_procedures_list.next(l_procedures_pos);\n\n\n\n\n\n\n\n\nend\n\n\n      end loop;\n\n\n\n\n\n\n\n\n\n\n      l_annotation_pos := a_annotation_texts.next(l_annotation_pos);\n\n\n\n\n\n\n\n\nend\n\n\n    end loop;\n\n\n\n\n\n\n\n\nreturn\n\n\n    return l_result;\n\n\n\n\n\n\n\n\nl_line_no\n\n\n    l_line_no           binary_integer;\n\n\n\n\n\n\n\n\n\n\n  l_line_no := a_annotations(a_for_annotation).next( l_line_no );\n\n\n\n\n\n\n\n\nend\n\n\nend loop;\n\n\n\n\n\n\n\n\nend\n\n\n      end if;\n\n\n\n\n\n\n\n\nend\n\n\n    end if;\n\n\n\n\n\n\n\n\nl_warning\n\n\n    l_warning         varchar2(32767);\n\n\n\n\n\n\n\n\nl_line_no\n\n\n    l_line_no           binary_integer;\n\n\n\n\n\n\n\n\n\n\n    l_line_no := a_proc_annotations(l_annotation_name).next(l_line_no);\n\n\n\n\n\n\n\n\nend\n\n\n  end loop;\n\n\n\n\n\n\n\n\nend\n\n\nend if;\n\n\n\n\n\n\n\n\n\n\nl_annotation_name := a_proc_annotations.next(l_annotation_name);\n\n\n\n\n\n\n\n\nend\n\n\n      end loop;\n\n\n\n\n\n\n\n\nend\n\n\n    end if;\n\n\n\n\n\n\n\n\nl_annotation_texts\n\n\n    l_annotation_texts tt_annotation_texts;\n\n\n\n\n\n\n\n\nl_annotation_pos\n\n\n    l_annotation_pos   binary_integer;\n\n\n\n\n\n\n\n\nend\n\n\n    end if;\n\n\n\n\n\n\n\n\n\n\n    \n    l_test := ut_test(a_suite.object_owner, a_suite.object_name, a_procedure_name);\n\n\n\n\n\n\n\n\nelse\n\n\n    else\n      l_test.description := a_proc_annotations(gc_test)(a_proc_annotations(gc_test).first);\n\n\n\n\n\n\n\n\nend\n\n\n    end if;\n\n\n\n\n\n\n\n\nend\n\n\n      end if;\n\n\n\n\n\n\n\n\nend\n\n\n    end if;\n\n\n\n\n\n\n\n\nend\n\n\n    end if;\n\n\n\n\n\n\n\n\nend\n\n\n    end if;\n\n\n\n\n\n\n\n\nend\n\n\n    end if;\n\n\n\n\n\n\n\n\nl_context\n\n\n    l_context   ut_logical_suite;\n\n\n\n\n\n\n\n\nend\n\n\nend if;\n\n\n\n\n\n\n\n\nend\n\n\n      end loop;\n\n\n\n\n\n\n\n\nend\n\n\n    end if;\n\n\n\n\n\n\n\n\nend\n\n\n    end if;\n\n\n\n\n\n\n\n\nl_tests\n\n\n    l_tests            tt_tests;\n\n\n\n\n\n\n\n\nbegin\n\n\n  begin\n    l_procedure_name := a_proc_annotations.first;\n\n\n\n\n\n\n\n\n\n\n      l_procedure_name := a_proc_annotations.next( l_procedure_name );\n\n\n\n\n\n\n\n\nend\n\n\n    end loop;\n\n\n\n\n\n\n\n\nend\n\n\nend if;\n\n\n\n\n\n\n\n\nend\n\n\n      end if;\n\n\n\n\n\n\n\n\nend\n\n\n    end if;\n\n\n\n\n\n\n\n\nl_after_each_list\n\n\n    l_after_each_list    tt_executables;\n\n\n\n\n\n\n\n\nl_before_all_list\n\n\n    l_before_all_list    tt_executables;\n\n\n\n\n\n\n\n\nl_after_all_list\n\n\n    l_after_all_list     tt_executables;\n\n\n\n\n\n\n\n\nl_executables\n\n\n    l_executables        ut_executables;\n\n\n\n\n\n\n\n\nl_rollback_type\n\n\n    l_rollback_type      ut_utils.t_rollback_type;\n\n\n\n\n\n\n\n\nl_annotation_text\n\n\n    l_annotation_text    t_annotation_text;\n\n\n\n\n\n\n\n\nend\n\n\n      end if;\n\n\n\n\n\n\n\n\nend\n\n\n    end if;\n\n\n\n\n\n\n\n\nend\n\n\n      end if;\n\n\n\n\n\n\n\n\nend\n\n\n    end if;\n\n\n\n\n\n\n\n\nend\n\n\n    end if;\n\n\n\n\n\n\n\n\nend\n\n\n    end if;\n\n\n\n\n\n\n\n\nend\n\n\n    end if;\n\n\n\n\n\n\n\n\nend\n\n\n    end if;\n\n\n\n\n\n\n\n\nl_end_context_pos\n\n\n    l_end_context_pos    t_annotation_position;\n\n\n\n\n\n\n\n\nl_context_name\n\n\n    l_context_name       t_object_name;\n\n\n\n\n\n\n\n\nl_ctx_annotations\n\n\n    l_ctx_annotations    t_annotations_info;\n\n\n\n\n\n\n\n\nl_context\n\n\n    l_context            ut_suite_context;\n\n\n\n\n\n\n\n\nl_context_no\n\n\n    l_context_no         binary_integer := 1;\n\n\n\n\n\n\n\n\nend\n\n\nend loop;\n\n\n\n\n\n\n\n\nend\n\n\n      end if;\n\n\n\n\n\n\n\n\nreturn\n\n\n      return l_result;\n\n\n\n\n\n\n\n\nl_position\n\n\n      l_position        t_annotation_position;\n\n\n\n\n\n\n\n\nl_procedure_name\n\n\n      l_procedure_name  t_object_name;\n\n\n\n\n\n\n\n\nl_annotation_name\n\n\n      l_annotation_name t_annotation_name;\n\n\n\n\n\n\n\n\nl_annotation_text\n\n\n      l_annotation_text t_annotation_text;\n\n\n\n\n\n\n\n\nbegin\n\n\n    begin\n      l_position := a_context_pos;\n\n\n\n\n\n\n\n\n\n\nl_procedure_name  := l_result.by_line(l_position).procedure_name;\n\n\n\n\n\n\n\n\n\n\nl_annotation_name := l_result.by_line(l_position).name;\n\n\n\n\n\n\n\n\n\n\nl_annotation_text := l_result.by_line(l_position).text;\n\n\n\n\n\n\n\n\nelse\n\n\nelse\n  l_result.by_name(l_annotation_name)(l_position) := l_annotation_text;\n\n\n\n\n\n\n\n\nend\n\n\nend if;\n\n\n\n\n\n\n\n\n\n\nl_position := a_annotations.by_line.next(l_position);\n\n\n\n\n\n\n\n\nend\n\n\n      end loop;\n\n\n\n\n\n\n\n\nreturn\n\n\n      return l_result;\n\n\n\n\n\n\n\n\nend\n\n\n    end if;\n\n\n\n\n\n\n\n\n\n\n    l_context_pos := a_annotations.by_name( gc_context).first;\n\n\n\n\n\n\n\n\nend\n\n\n      end if;\n\n\n\n\n\n\n\n\n\n\n      l_ctx_annotations   := get_annotations_in_context( a_annotations, l_context_pos, l_end_context_pos);\n\n\n\n\n\n\n\n\n\n\n      l_context := ut_suite_context(a_suite.object_owner, a_suite.object_name, l_context_name );\n\n\n\n\n\n\n\n\nexit\n\n\n      exit when not a_annotations.by_name.exists( gc_context);\n\n\n\n\n\n\n\n\n\n\n      l_context_pos := a_annotations.by_name( gc_context).next( l_context_pos);\n\n\n\n\n\n\n\n\n\n\n      l_context_no := l_context_no + 1;\n\n\n\n\n\n\n\n\nend\n\n\n    end loop;\n\n\n\n\n\n\n\n\n\n\nl_annotation_pos := a_package_ann_index(gc_context).next(l_annotation_pos);\n\n\n\n\n\n\n\n\nend\n\n\n      end loop;\n\n\n\n\n\n\n\n\nend\n\n\n    end if;\n\n\n\n\n\n\n\n\n\n\nl_annotation_pos := a_package_ann_index(gc_endcontext).next(l_annotation_pos);\n\n\n\n\n\n\n\n\nend\n\n\n      end loop;\n\n\n\n\n\n\n\n\nend\n\n\n    end if;\n\n\n\n\n\n\n\n\nl_annotation_pos\n\n\n    l_annotation_pos t_annotation_position;\n\n\n\n\n\n\n\n\nl_suite\n\n\n    l_suite          ut_suite;\n\n\n\n\n\n\n\n\n\n\n      l_annotation_pos := l_annotations.by_name( gc_suite).first;\n\n\n\n\n\n\n\n\nend\n\n\n    end if;\n\n\n\n\n\n\n\n\nreturn\n\n\n    return l_suite;\n\n\n\n\n\n\n\n\nl_suite_path\n\n\n    l_suite_path        varchar2(4000 char);\n\n\n\n\n\n\n\n\nl_parent_path\n\n\n    l_parent_path       varchar2(4000 char);\n\n\n\n\n\n\n\n\nl_name\n\n\n    l_name              varchar2(4000 char);\n\n\n\n\n\n\n\n\nl_suites_by_path\n\n\n    l_suites_by_path    tt_schema_suites;\n\n\n\n\n\n\n\n\nbegin\n\n\n  begin\n    l_suites_by_path := a_suites_by_path;\n\n\n\n\n\n\n\n\n\n\n    l_suite_path  := l_suites_by_path.last;\n\n\n\n\n\n\n\n\nelse\n\n\nelse\n  ut_utils.debug_log('  Parent suite \"'\n\n\n\n\n\n\n\n\nend\n\n\nend if;\n\n\n\n\n\n\n\n\nend\n\n\n      end if;\n\n\n\n\n\n\n\n\n\n\n      l_suite_path := l_suites_by_path.prior(l_suite_path);\n\n\n\n\n\n\n\n\nend\n\n\n    end loop;\n\n\n\n\n\n\n\n\nreturn\n\n\n    return l_result;\n\n\n\n\n\n\n\n\nl_annotated_objects\n\n\n    l_annotated_objects ut_annotated_objects;\n\n\n\n\n\n\n\n\nl_all_suites\n\n\n    l_all_suites        tt_schema_suites;\n\n\n\n\n\n\n\n\nl_result\n\n\n    l_result            t_schema_suites_info;\n\n\n\n\n\n\n\n\nl_annotation\n\n\n      l_annotation      t_annotation;\n\n\n\n\n\n\n\n\nl_annotation_no\n\n\n      l_annotation_no   binary_integer;\n\n\n\n\n\n\n\n\nl_annotation_pos\n\n\n      l_annotation_pos  binary_integer;\n\n\n\n\n\n\n\n\nbegin\n\n\n    begin\n      l_result.owner := a_object.object_owner;\n\n\n\n\n\n\n\n\n\n\n      l_annotation_no := a_object.annotations.first;\n\n\n\n\n\n\n\n\nelse\n\n\nelse\n  l_result.by_proc(l_annotation.procedure_name)(l_annotation.name)(l_annotation_pos) := l_annotation.text;\n\n\n\n\n\n\n\n\nend\n\n\nend if;\n\n\n\n\n\n\n\n\n\n\nl_annotation_no := a_object.annotations.next(l_annotation_no);\n\n\n\n\n\n\n\n\nend\n\n\n      end loop;\n\n\n\n\n\n\n\n\nreturn\n\n\n      return l_result;\n\n\n\n\n\n\n\n\nbegin\n\n\n  begin\n    fetch a_annotated_objects bulk collect into l_annotated_objects;\n\n\n\n\n\n\n\n\nclose\n\n\n    close a_annotated_objects;\n\n\n\n\n\n\n\n\nend\n\n\n      end if;\n\n\n\n\n\n\n\n\nend\n\n\n    end loop;\n\n\n\n\n\n\n\n\nreturn\n\n\n    return l_result;\n\n\n\n\n\n\n\n\nreturn\n\n\n    return build_suites(l_annotations_cursor);\n\n\n\n\n\n\n\n\nend\n\n\nend ut_suite_builder;\n\n\n\n\n\n\n\n\n\n\nBUILD_SCHEMA_SUITES Function\n\n\n\n\nBuilds set of hierarchical suites for a given schema\n\n\n\n\n\nSyntax\n\n\nfunction build_schema_suites(a_owner_name varchar2) return t_schema_suites_info\n\n\n\n\nParameters\n\n\n\n\n\n\n\n\nName\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\na_owner_name\n\n\nname of the schema to builds suites for\n\n\n\n\n\n\nreturn\n\n\nlist of suites organized into hierarchy\n\n\n\n\n\n\n\n\nBUILD_SUITES Function\n\n\n\n\nBuilds set of hierarchical suites for given annotations\n\n\n\n\n\nSyntax\n\n\nfunction build_suites(a_annotated_objects sys_refcursor) return t_schema_suites_info\n\n\n\n\nParameters\n\n\n\n\n\n\n\n\nName\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\na_annotated_objects\n\n\ncursor returning ut_annotated_object type\n\n\n\n\n\n\nreturn\n\n\nlist of suites organized into hierarchy", 
            "title": "UT_SUITE_BUILDER"
        }, 
        {
            "location": "/ut_suite_builder/#ut_suite_builder", 
            "text": "Data Types    Variables    Exceptions    BUILD_SCHEMA_SUITES Function   BUILD_SUITES Function", 
            "title": "UT_SUITE_BUILDER"
        }, 
        {
            "location": "/ut_suite_builder/#types", 
            "text": "Name  Code  Description      t_annotation_text  subtype t_annotation_text     is varchar2(4000);     t_annotation_name  subtype t_annotation_name     is varchar2(4000);     t_object_name  subtype t_object_name         is varchar2(500);     t_annotation_position  subtype t_annotation_position is binary_integer;     tt_executables  type tt_executables is table of ut_executables index by t_annotation_position;     tt_tests  type tt_tests is table of ut_test index by t_annotation_position;     t_annotation  type t_annotation is record(   name                  t_annotation_name,   text                  t_annotation_text,   procedure_name        t_object_name );     tt_annotations_by_line  type tt_annotations_by_line is table of t_annotation index by t_annotation_position;     tt_annotations_by_name  type tt_annotations_by_name is table of tt_annotation_texts index by t_annotation_name;     tt_annotations_by_proc  type tt_annotations_by_proc is table of tt_annotations_by_name index by t_object_name;     t_annotations_info  type t_annotations_info is record (   owner   t_object_name,   name    t_object_name,   by_line tt_annotations_by_line,   by_proc tt_annotations_by_proc,   by_name tt_annotations_by_name );", 
            "title": "Types"
        }, 
        {
            "location": "/ut_suite_builder/#variables", 
            "text": "Name  Code  Description       l_throws_list := ut_utils.trim_list_elements(ut_utils.string_to_table(a_annotation_text, ',', 'Y'));     end  end if;     else  else   l_exception_number_list.extend;     end  end if;      l_exception_number := null;     end        end loop;     return        return l_exception_number_list;     begin    begin     a_list := ut_integer_list();          l_annotation_pos := a_throws_ann_text.first;     end        end if;            l_annotation_pos := a_throws_ann_text.next(l_annotation_pos);     end      end loop;     l_pos      l_pos   t_annotation_position := a_list.first;      l_pos := a_list.next(l_pos);     end        end loop;     return        return l_result;     l_pos      l_pos   t_annotation_position := a_list.first;      l_pos := a_list.next(l_pos);     end        end loop;     return        return l_result;     end        end if;     l_result      l_result          tt_executables;     l_annotation_pos      l_annotation_pos  binary_integer;     l_procedures_list      l_procedures_list ut_varchar2_list;     l_procedures_pos      l_procedures_pos  binary_integer;     l_components_list      l_components_list ut_varchar2_list;     begin    begin     l_annotation_pos := a_annotation_texts.first;            l_procedures_pos := l_procedures_list.first;            l_executables := ut_executables();      l_procedures_pos := l_procedures_list.next(l_procedures_pos);     end        end loop;            l_annotation_pos := a_annotation_texts.next(l_annotation_pos);     end      end loop;     return      return l_result;     l_line_no      l_line_no           binary_integer;        l_line_no := a_annotations(a_for_annotation).next( l_line_no );     end  end loop;     end        end if;     end      end if;     l_warning      l_warning         varchar2(32767);     l_line_no      l_line_no           binary_integer;          l_line_no := a_proc_annotations(l_annotation_name).next(l_line_no);     end    end loop;     end  end if;      l_annotation_name := a_proc_annotations.next(l_annotation_name);     end        end loop;     end      end if;     l_annotation_texts      l_annotation_texts tt_annotation_texts;     l_annotation_pos      l_annotation_pos   binary_integer;     end      end if;               l_test := ut_test(a_suite.object_owner, a_suite.object_name, a_procedure_name);     else      else       l_test.description := a_proc_annotations(gc_test)(a_proc_annotations(gc_test).first);     end      end if;     end        end if;     end      end if;     end      end if;     end      end if;     end      end if;     l_context      l_context   ut_logical_suite;     end  end if;     end        end loop;     end      end if;     end      end if;     l_tests      l_tests            tt_tests;     begin    begin     l_procedure_name := a_proc_annotations.first;            l_procedure_name := a_proc_annotations.next( l_procedure_name );     end      end loop;     end  end if;     end        end if;     end      end if;     l_after_each_list      l_after_each_list    tt_executables;     l_before_all_list      l_before_all_list    tt_executables;     l_after_all_list      l_after_all_list     tt_executables;     l_executables      l_executables        ut_executables;     l_rollback_type      l_rollback_type      ut_utils.t_rollback_type;     l_annotation_text      l_annotation_text    t_annotation_text;     end        end if;     end      end if;     end        end if;     end      end if;     end      end if;     end      end if;     end      end if;     end      end if;     l_end_context_pos      l_end_context_pos    t_annotation_position;     l_context_name      l_context_name       t_object_name;     l_ctx_annotations      l_ctx_annotations    t_annotations_info;     l_context      l_context            ut_suite_context;     l_context_no      l_context_no         binary_integer := 1;     end  end loop;     end        end if;     return        return l_result;     l_position        l_position        t_annotation_position;     l_procedure_name        l_procedure_name  t_object_name;     l_annotation_name        l_annotation_name t_annotation_name;     l_annotation_text        l_annotation_text t_annotation_text;     begin      begin       l_position := a_context_pos;      l_procedure_name  := l_result.by_line(l_position).procedure_name;      l_annotation_name := l_result.by_line(l_position).name;      l_annotation_text := l_result.by_line(l_position).text;     else  else   l_result.by_name(l_annotation_name)(l_position) := l_annotation_text;     end  end if;      l_position := a_annotations.by_line.next(l_position);     end        end loop;     return        return l_result;     end      end if;          l_context_pos := a_annotations.by_name( gc_context).first;     end        end if;            l_ctx_annotations   := get_annotations_in_context( a_annotations, l_context_pos, l_end_context_pos);            l_context := ut_suite_context(a_suite.object_owner, a_suite.object_name, l_context_name );     exit        exit when not a_annotations.by_name.exists( gc_context);            l_context_pos := a_annotations.by_name( gc_context).next( l_context_pos);            l_context_no := l_context_no + 1;     end      end loop;      l_annotation_pos := a_package_ann_index(gc_context).next(l_annotation_pos);     end        end loop;     end      end if;      l_annotation_pos := a_package_ann_index(gc_endcontext).next(l_annotation_pos);     end        end loop;     end      end if;     l_annotation_pos      l_annotation_pos t_annotation_position;     l_suite      l_suite          ut_suite;            l_annotation_pos := l_annotations.by_name( gc_suite).first;     end      end if;     return      return l_suite;     l_suite_path      l_suite_path        varchar2(4000 char);     l_parent_path      l_parent_path       varchar2(4000 char);     l_name      l_name              varchar2(4000 char);     l_suites_by_path      l_suites_by_path    tt_schema_suites;     begin    begin     l_suites_by_path := a_suites_by_path;          l_suite_path  := l_suites_by_path.last;     else  else   ut_utils.debug_log('  Parent suite \"'     end  end if;     end        end if;            l_suite_path := l_suites_by_path.prior(l_suite_path);     end      end loop;     return      return l_result;     l_annotated_objects      l_annotated_objects ut_annotated_objects;     l_all_suites      l_all_suites        tt_schema_suites;     l_result      l_result            t_schema_suites_info;     l_annotation        l_annotation      t_annotation;     l_annotation_no        l_annotation_no   binary_integer;     l_annotation_pos        l_annotation_pos  binary_integer;     begin      begin       l_result.owner := a_object.object_owner;            l_annotation_no := a_object.annotations.first;     else  else   l_result.by_proc(l_annotation.procedure_name)(l_annotation.name)(l_annotation_pos) := l_annotation.text;     end  end if;      l_annotation_no := a_object.annotations.next(l_annotation_no);     end        end loop;     return        return l_result;     begin    begin     fetch a_annotated_objects bulk collect into l_annotated_objects;     close      close a_annotated_objects;     end        end if;     end      end loop;     return      return l_result;     return      return build_suites(l_annotations_cursor);     end  end ut_suite_builder;", 
            "title": "Variables"
        }, 
        {
            "location": "/ut_suite_builder/#exceptions", 
            "text": "Name  Code  Description       l_throws_list := ut_utils.trim_list_elements(ut_utils.string_to_table(a_annotation_text, ',', 'Y'));     end  end if;     else  else   l_exception_number_list.extend;     end  end if;      l_exception_number := null;     end        end loop;     return        return l_exception_number_list;     begin    begin     a_list := ut_integer_list();          l_annotation_pos := a_throws_ann_text.first;     end        end if;            l_annotation_pos := a_throws_ann_text.next(l_annotation_pos);     end      end loop;     l_pos      l_pos   t_annotation_position := a_list.first;      l_pos := a_list.next(l_pos);     end        end loop;     return        return l_result;     l_pos      l_pos   t_annotation_position := a_list.first;      l_pos := a_list.next(l_pos);     end        end loop;     return        return l_result;     end        end if;     l_result      l_result          tt_executables;     l_annotation_pos      l_annotation_pos  binary_integer;     l_procedures_list      l_procedures_list ut_varchar2_list;     l_procedures_pos      l_procedures_pos  binary_integer;     l_components_list      l_components_list ut_varchar2_list;     begin    begin     l_annotation_pos := a_annotation_texts.first;            l_procedures_pos := l_procedures_list.first;            l_executables := ut_executables();      l_procedures_pos := l_procedures_list.next(l_procedures_pos);     end        end loop;            l_annotation_pos := a_annotation_texts.next(l_annotation_pos);     end      end loop;     return      return l_result;     l_line_no      l_line_no           binary_integer;        l_line_no := a_annotations(a_for_annotation).next( l_line_no );     end  end loop;     end        end if;     end      end if;     l_warning      l_warning         varchar2(32767);     l_line_no      l_line_no           binary_integer;          l_line_no := a_proc_annotations(l_annotation_name).next(l_line_no);     end    end loop;     end  end if;      l_annotation_name := a_proc_annotations.next(l_annotation_name);     end        end loop;     end      end if;     l_annotation_texts      l_annotation_texts tt_annotation_texts;     l_annotation_pos      l_annotation_pos   binary_integer;     end      end if;               l_test := ut_test(a_suite.object_owner, a_suite.object_name, a_procedure_name);     else      else       l_test.description := a_proc_annotations(gc_test)(a_proc_annotations(gc_test).first);     end      end if;     end        end if;     end      end if;     end      end if;     end      end if;     end      end if;     l_context      l_context   ut_logical_suite;     end  end if;     end        end loop;     end      end if;     end      end if;     l_tests      l_tests            tt_tests;     begin    begin     l_procedure_name := a_proc_annotations.first;            l_procedure_name := a_proc_annotations.next( l_procedure_name );     end      end loop;     end  end if;     end        end if;     end      end if;     l_after_each_list      l_after_each_list    tt_executables;     l_before_all_list      l_before_all_list    tt_executables;     l_after_all_list      l_after_all_list     tt_executables;     l_executables      l_executables        ut_executables;     l_rollback_type      l_rollback_type      ut_utils.t_rollback_type;     l_annotation_text      l_annotation_text    t_annotation_text;     end        end if;     end      end if;     end        end if;     end      end if;     end      end if;     end      end if;     end      end if;     end      end if;     l_end_context_pos      l_end_context_pos    t_annotation_position;     l_context_name      l_context_name       t_object_name;     l_ctx_annotations      l_ctx_annotations    t_annotations_info;     l_context      l_context            ut_suite_context;     l_context_no      l_context_no         binary_integer := 1;     end  end loop;     end        end if;     return        return l_result;     l_position        l_position        t_annotation_position;     l_procedure_name        l_procedure_name  t_object_name;     l_annotation_name        l_annotation_name t_annotation_name;     l_annotation_text        l_annotation_text t_annotation_text;     begin      begin       l_position := a_context_pos;      l_procedure_name  := l_result.by_line(l_position).procedure_name;      l_annotation_name := l_result.by_line(l_position).name;      l_annotation_text := l_result.by_line(l_position).text;     else  else   l_result.by_name(l_annotation_name)(l_position) := l_annotation_text;     end  end if;      l_position := a_annotations.by_line.next(l_position);     end        end loop;     return        return l_result;     end      end if;          l_context_pos := a_annotations.by_name( gc_context).first;     end        end if;            l_ctx_annotations   := get_annotations_in_context( a_annotations, l_context_pos, l_end_context_pos);            l_context := ut_suite_context(a_suite.object_owner, a_suite.object_name, l_context_name );     exit        exit when not a_annotations.by_name.exists( gc_context);            l_context_pos := a_annotations.by_name( gc_context).next( l_context_pos);            l_context_no := l_context_no + 1;     end      end loop;      l_annotation_pos := a_package_ann_index(gc_context).next(l_annotation_pos);     end        end loop;     end      end if;      l_annotation_pos := a_package_ann_index(gc_endcontext).next(l_annotation_pos);     end        end loop;     end      end if;     l_annotation_pos      l_annotation_pos t_annotation_position;     l_suite      l_suite          ut_suite;            l_annotation_pos := l_annotations.by_name( gc_suite).first;     end      end if;     return      return l_suite;     l_suite_path      l_suite_path        varchar2(4000 char);     l_parent_path      l_parent_path       varchar2(4000 char);     l_name      l_name              varchar2(4000 char);     l_suites_by_path      l_suites_by_path    tt_schema_suites;     begin    begin     l_suites_by_path := a_suites_by_path;          l_suite_path  := l_suites_by_path.last;     else  else   ut_utils.debug_log('  Parent suite \"'     end  end if;     end        end if;            l_suite_path := l_suites_by_path.prior(l_suite_path);     end      end loop;     return      return l_result;     l_annotated_objects      l_annotated_objects ut_annotated_objects;     l_all_suites      l_all_suites        tt_schema_suites;     l_result      l_result            t_schema_suites_info;     l_annotation        l_annotation      t_annotation;     l_annotation_no        l_annotation_no   binary_integer;     l_annotation_pos        l_annotation_pos  binary_integer;     begin      begin       l_result.owner := a_object.object_owner;            l_annotation_no := a_object.annotations.first;     else  else   l_result.by_proc(l_annotation.procedure_name)(l_annotation.name)(l_annotation_pos) := l_annotation.text;     end  end if;      l_annotation_no := a_object.annotations.next(l_annotation_no);     end        end loop;     return        return l_result;     begin    begin     fetch a_annotated_objects bulk collect into l_annotated_objects;     close      close a_annotated_objects;     end        end if;     end      end loop;     return      return l_result;     return      return build_suites(l_annotations_cursor);     end  end ut_suite_builder;", 
            "title": "Exceptions"
        }, 
        {
            "location": "/ut_suite_builder/#build_schema_suites-function", 
            "text": "Builds set of hierarchical suites for a given schema", 
            "title": "BUILD_SCHEMA_SUITES Function"
        }, 
        {
            "location": "/ut_suite_builder/#syntax", 
            "text": "function build_schema_suites(a_owner_name varchar2) return t_schema_suites_info", 
            "title": "Syntax"
        }, 
        {
            "location": "/ut_suite_builder/#parameters", 
            "text": "Name  Description      a_owner_name  name of the schema to builds suites for    return  list of suites organized into hierarchy", 
            "title": "Parameters"
        }, 
        {
            "location": "/ut_suite_builder/#build_suites-function", 
            "text": "Builds set of hierarchical suites for given annotations", 
            "title": "BUILD_SUITES Function"
        }, 
        {
            "location": "/ut_suite_builder/#syntax_1", 
            "text": "function build_suites(a_annotated_objects sys_refcursor) return t_schema_suites_info", 
            "title": "Syntax"
        }, 
        {
            "location": "/ut_suite_builder/#parameters_1", 
            "text": "Name  Description      a_annotated_objects  cursor returning ut_annotated_object type    return  list of suites organized into hierarchy", 
            "title": "Parameters"
        }, 
        {
            "location": "/ut_suite_manager/", 
            "text": "UT_SUITE_MANAGER\n\n\n\n\n\n\nData Types\n\n\n\n\n\n\nGET_SCHEMA_UT_PACKAGES Function\n\n\n\n\nCONFIGURE_EXECUTION_BY_PATH Function\n\n\nGET_SCHEMA_NAMES Function\n\n\n\n\nTypes\n\n\n\n\n\n\n\n\nName\n\n\nCode\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ntt_schema_suites\n\n\nsubtype tt_schema_suites is ut_suite_builder.tt_schema_suites;\n\n\n\n\n\n\n\n\nt_object_suite_path\n\n\nsubtype t_object_suite_path is ut_suite_builder.t_object_suite_path;\n\n\n\n\n\n\n\n\nt_schema_suites_info\n\n\nsubtype t_schema_suites_info is ut_suite_builder.t_schema_suites_info;\n\n\n\n\n\n\n\n\nt_schema_info\n\n\ntype t_schema_info is record (changed_at date, obj_cnt integer);\n\n\n\n\n\n\n\n\nt_schema_cache\n\n\ntype t_schema_cache is record(\n   schema_suites tt_schema_suites\n  ,changed_at    date\n  ,obj_cnt       integer\n  ,suite_paths   t_object_suite_path\n);\n\n\n\n\n\n\n\n\ntt_schema_suites_list\n\n\ntype tt_schema_suites_list is table of t_schema_cache index by varchar2(128 char);\n\n\n\n\n\n\n\n\nt_schema_paths\n\n\ntype t_schema_paths is table of ut_varchar2_list index by varchar2(4000 char);\n\n\n\n\n\n\n\n\n\n\nCONFIGURE_EXECUTION_BY_PATH Function\n\n\n\n\nBuilds a hierarchical suites based on given suite-paths\n\n\n\n\n\nSyntax\n\n\nfunction configure_execution_by_path(a_paths in ut_varchar2_list) return ut_suite_items\n\n\n\n\nParameters\n\n\n\n\n\n\n\n\nName\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\na_paths\n\n\nlist of suite-paths or procedure names or package names or schema names\n\n\n\n\n\n\nreturn\n\n\narray containing root suites-ready to be executed\n\n\n\n\n\n\n\n\nGET_SCHEMA_NAMES Function\n\n\n\n\nCleanup paths by removing leading/trailing whitespace and making paths lowercase\nGet list of schema names from execution paths.\n\n\n\n\n\nSyntax\n\n\nfunction get_schema_names(a_paths ut_varchar2_list) return ut_varchar2_rows", 
            "title": "UT_SUITE_MANAGER"
        }, 
        {
            "location": "/ut_suite_manager/#ut_suite_manager", 
            "text": "Data Types    GET_SCHEMA_UT_PACKAGES Function   CONFIGURE_EXECUTION_BY_PATH Function  GET_SCHEMA_NAMES Function", 
            "title": "UT_SUITE_MANAGER"
        }, 
        {
            "location": "/ut_suite_manager/#types", 
            "text": "Name  Code  Description      tt_schema_suites  subtype tt_schema_suites is ut_suite_builder.tt_schema_suites;     t_object_suite_path  subtype t_object_suite_path is ut_suite_builder.t_object_suite_path;     t_schema_suites_info  subtype t_schema_suites_info is ut_suite_builder.t_schema_suites_info;     t_schema_info  type t_schema_info is record (changed_at date, obj_cnt integer);     t_schema_cache  type t_schema_cache is record(    schema_suites tt_schema_suites   ,changed_at    date   ,obj_cnt       integer   ,suite_paths   t_object_suite_path );     tt_schema_suites_list  type tt_schema_suites_list is table of t_schema_cache index by varchar2(128 char);     t_schema_paths  type t_schema_paths is table of ut_varchar2_list index by varchar2(4000 char);", 
            "title": "Types"
        }, 
        {
            "location": "/ut_suite_manager/#configure_execution_by_path-function", 
            "text": "Builds a hierarchical suites based on given suite-paths", 
            "title": "CONFIGURE_EXECUTION_BY_PATH Function"
        }, 
        {
            "location": "/ut_suite_manager/#syntax", 
            "text": "function configure_execution_by_path(a_paths in ut_varchar2_list) return ut_suite_items", 
            "title": "Syntax"
        }, 
        {
            "location": "/ut_suite_manager/#parameters", 
            "text": "Name  Description      a_paths  list of suite-paths or procedure names or package names or schema names    return  array containing root suites-ready to be executed", 
            "title": "Parameters"
        }, 
        {
            "location": "/ut_suite_manager/#get_schema_names-function", 
            "text": "Cleanup paths by removing leading/trailing whitespace and making paths lowercase Get list of schema names from execution paths.", 
            "title": "GET_SCHEMA_NAMES Function"
        }, 
        {
            "location": "/ut_suite_manager/#syntax_1", 
            "text": "function get_schema_names(a_paths ut_varchar2_list) return ut_varchar2_rows", 
            "title": "Syntax"
        }, 
        {
            "location": "/ut_teamcity_reporter_helper/", 
            "text": "UT_TEAMCITY_REPORTER_HELPER\n\n\n\n\n\n\nData Types\n\n\n\n\n\n\nTEST_SUITE_STARTED Function\n\n\n\n\n\n\nTypes\n\n\n\n\n\n\n\n\nName\n\n\nCode\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nt_prop_index\n\n\nsubtype t_prop_index is varchar2(2000 char);\n\n\n\n\n\n\n\n\nt_props\n\n\ntype t_props is table of varchar2(32767) index by t_prop_index;\n\n\n\n\n\n\n\n\n\n\nTEST_SUITE_STARTED Function\n\n\n\n\nutPLSQL - Version 3\n  Copyright 2016 - 2017 utPLSQL Project\n  Licensed under the Apache License, Version 2.0 (the \nLicense\n):\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n  http://www.apache.org/licenses/LICENSE-2.0\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \nAS IS\n BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n\n\n\n\n\nSyntax\n\n\nfunction test_suite_started(a_suite_name varchar2, a_flow_id varchar2 default null) return varchar2", 
            "title": "UT_TEAMCITY_REPORTER_HELPER"
        }, 
        {
            "location": "/ut_teamcity_reporter_helper/#ut_teamcity_reporter_helper", 
            "text": "Data Types    TEST_SUITE_STARTED Function", 
            "title": "UT_TEAMCITY_REPORTER_HELPER"
        }, 
        {
            "location": "/ut_teamcity_reporter_helper/#types", 
            "text": "Name  Code  Description      t_prop_index  subtype t_prop_index is varchar2(2000 char);     t_props  type t_props is table of varchar2(32767) index by t_prop_index;", 
            "title": "Types"
        }, 
        {
            "location": "/ut_teamcity_reporter_helper/#test_suite_started-function", 
            "text": "utPLSQL - Version 3   Copyright 2016 - 2017 utPLSQL Project   Licensed under the Apache License, Version 2.0 (the  License ):   you may not use this file except in compliance with the License.   You may obtain a copy of the License at   http://www.apache.org/licenses/LICENSE-2.0   Unless required by applicable law or agreed to in writing, software   distributed under the License is distributed on an  AS IS  BASIS,   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   See the License for the specific language governing permissions and   limitations under the License.", 
            "title": "TEST_SUITE_STARTED Function"
        }, 
        {
            "location": "/ut_teamcity_reporter_helper/#syntax", 
            "text": "function test_suite_started(a_suite_name varchar2, a_flow_id varchar2 default null) return varchar2", 
            "title": "Syntax"
        }, 
        {
            "location": "/ut_utils/", 
            "text": "UT_UTILS\n\n\n\n\n\n\nData Types\n\n\n\n\n\n\nConstants\n\n\n\n\n\n\nSURROUND_WITH Function\n\n\n\n\nVALIDATE_ROLLBACK_TYPE Procedure\n\n\nTEST_RESULT_TO_CHAR Function\n\n\nGEN_SAVEPOINT_NAME Function\n\n\nSTRING_TO_TABLE Function\n\n\nCLOB_TO_TABLE Function\n\n\nTIME_DIFF Function\n\n\nINDENT_LINES Function\n\n\nGET_UTPLSQL_OBJECTS_LIST Function\n\n\nAPPEND_TO_LIST Procedure\n\n\nSET_ACTION Procedure\n\n\nSET_CLIENT_INFO Procedure\n\n\nTO_VERSION Function\n\n\nSAVE_DBMS_OUTPUT_TO_CACHE Procedure\n\n\nREAD_CACHE_TO_DBMS_OUTPUT Procedure\n\n\nUT_OWNER Function\n\n\nSCALE_CARDINALITY Function\n\n\nTO_XML_NUMBER_FORMAT Function\n\n\nGET_XML_HEADER Function\n\n\nTRIM_LIST_ELEMENTS Function\n\n\nFILTER_LIST Function\n\n\nREPLACE_MULTILINE_COMMENTS Function\n\n\n\n\nTypes\n\n\n\n\n\n\n\n\nName\n\n\nCode\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nt_event_name\n\n\nsubtype t_event_name           is varchar2(30);\n\n\n\n\n\n\n\n\nt_executable_type\n\n\nsubtype t_executable_type      is varchar2(30);\n\n\n\n\n\n\n\n\nt_test_result\n\n\nsubtype t_test_result   is binary_integer range 0 .. 3;\n\n\n\n\n\n\n\n\nt_rollback_type\n\n\nsubtype t_rollback_type is binary_integer range 0 .. 1;\n\n\n\n\n\n\n\n\nt_version\n\n\ntype t_version is record(\n  major  natural,\n  minor  natural,\n  bugfix natural,\n  build  natural\n);\n\n\n\n\n\n\n\n\nt_clob_tab\n\n\ntype t_clob_tab is table of clob;\n\n\n\n\n\n\n\n\n\n\nConstants\n\n\n\n\n\n\n\n\nName\n\n\nCode\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ngc_version\n\n\ngc_version                 constant varchar2(50) := 'v3.1.2.2053-develop';\n\n\n\n\n\n\n\n\n\n\nSURROUND_WITH Function\n\n\n\n\nutPLSQL - Version 3\n  Copyright 2016 - 2017 utPLSQL Project\n  Licensed under the Apache License, Version 2.0 (the \nLicense\n):\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n  http://www.apache.org/licenses/LICENSE-2.0\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \nAS IS\n BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n\n\n\n\n\nSyntax\n\n\nfunction surround_with(a_value varchar2, a_quote_char varchar2) return varchar2\n\n\n\n\nVALIDATE_ROLLBACK_TYPE Procedure\n\n\n\n\nProcedure: validate_rollback_type\n   Validates passed value against supported rollback types\n\n\n\n\n\nSyntax\n\n\nprocedure validate_rollback_type(a_rollback_type number)\n\n\n\n\nTEST_RESULT_TO_CHAR Function\n\n\n\n\nConverts test results into strings\n\n\n\n\n\nSyntax\n\n\nfunction test_result_to_char(a_test_result integer) return varchar2\n\n\n\n\nParameters\n\n\n\n\n\n\n\n\nName\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\na_test_result\n\n\nnumeric representation of test result\n\n\n\n\n\n\nreturn\n\n\na string representation of a test_result.\n\n\n\n\n\n\n\n\nGEN_SAVEPOINT_NAME Function\n\n\n\n\nGenerates a unique name for a savepoint\nUses sys_guid, as timestamp gives only miliseconds on Windows and is not unique\nIssue: #506 for details on the implementation approach\n\n\n\n\n\nSyntax\n\n\nfunction gen_savepoint_name return varchar2\n\n\n\n\nSTRING_TO_TABLE Function\n\n\n\n\nSplits a given string into table of string by delimiter.\nThe delimiter gets removed.\nIf null passed as any of the parameters, empty table is returned.\nIf no occurence of a_delimiter found in a_text then text is returned as a single row of the table.\nIf no text between delimiters found then an empty row is returned, example:\n  string_to_table( \na,,b\n, \n,\n ) gives table ut_varchar2_list( \na\n, null, \nb\n );\n\n\n\n\n\nSyntax\n\n\nfunction string_to_table(a_string varchar2, a_delimiter varchar2:= chr(10), a_skip_leading_delimiter varchar2 := 'N') return ut_varchar2_list\n\n\n\n\nParameters\n\n\n\n\n\n\n\n\nName\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\na_string\n\n\nthe text to be split.\n\n\n\n\n\n\na_delimiter\n\n\nthe delimiter character or string\n\n\n\n\n\n\na_skip_leading_delimiter\n\n\ndetermines if the leading delimiter should be ignored, used by clob_to_table\n\n\n\n\n\n\nreturn\n\n\ntable of varchar2 values\n\n\n\n\n\n\n\n\nCLOB_TO_TABLE Function\n\n\n\n\nSplits a given string into table of string by delimiter.\nDefault value of a_max_amount is 8191 because of code can contains multibyte character.\nThe delimiter gets removed.\nIf null passed as any of the parameters, empty table is returned.\nIf split text is longer than a_max_amount it gets split into pieces of a_max_amount.\nIf no text between delimiters found then an empty row is returned, example:\n  string_to_table( \na,,b\n, \n,\n ) gives table ut_varchar2_list( \na\n, null, \nb\n );\n\n\n\n\n\nSyntax\n\n\nfunction clob_to_table(a_clob clob, a_max_amount integer := 8191, a_delimiter varchar2:= chr(10)) return ut_varchar2_list\n\n\n\n\nParameters\n\n\n\n\n\n\n\n\nName\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\na_clob\n\n\nthe text to be split.\n\n\n\n\n\n\na_delimiter\n\n\nthe delimiter character or string (default chr(10) )\n\n\n\n\n\n\na_max_amount\n\n\nthe maximum length of returned string (default 8191)\n\n\n\n\n\n\nreturn\n\n\ntable of varchar2 values\n\n\n\n\n\n\n\n\nTIME_DIFF Function\n\n\n\n\nReturns time difference in seconds (with miliseconds) between given timestamps\n\n\n\n\n\nSyntax\n\n\nfunction time_diff(a_start_time timestamp with time zone, a_end_time timestamp with time zone) return number\n\n\n\n\nINDENT_LINES Function\n\n\n\n\nReturns a text indented with spaces except the first line.\n\n\n\n\n\nSyntax\n\n\nfunction indent_lines(a_text varchar2, a_indent_size integer := 4, a_include_first_line boolean := false) return varchar2\n\n\n\n\nGET_UTPLSQL_OBJECTS_LIST Function\n\n\n\n\nReturns a list of object that are part of utPLSQL framework\n\n\n\n\n\nSyntax\n\n\nfunction get_utplsql_objects_list return ut_object_names\n\n\n\n\nAPPEND_TO_LIST Procedure\n\n\n\n\nAppend a item to the end of ut_varchar2_list\n\n\n\n\n\nSyntax\n\n\nprocedure append_to_list(a_list in out nocopy ut_varchar2_list, a_item varchar2)\n\n\n\n\nSET_ACTION Procedure\n\n\n\n\nSet session\ns action and module using dbms_application_info\n\n\n\n\n\nSyntax\n\n\nprocedure set_action(a_text in varchar2)\n\n\n\n\nSET_CLIENT_INFO Procedure\n\n\n\n\nSet session\ns client info using dbms_application_info\n\n\n\n\n\nSyntax\n\n\nprocedure set_client_info(a_text in varchar2)\n\n\n\n\nTO_VERSION Function\n\n\n\n\nConverts version string into version record\n\n\n\n\n\nSyntax\n\n\nfunction to_version(a_version_no varchar2) return t_version\n\n\n\n\nParameters\n\n\n\n\n\n\n\n\nName\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\na_version_no\n\n\nstring representation of version in format vX.X.X.X where X is a positive integer\n\n\n\n\n\n\nreturn\n\n\nt_version    record with up to four positive numbers containing version\n\n\n\n\n\n\n\n\nThrown exceptions\n\n\nthrows\n 20214 if passed version string is not matching version pattern\n\n\nSAVE_DBMS_OUTPUT_TO_CACHE Procedure\n\n\n\n\nSaves data from dbms_output buffer into a global temporary table (cache)\n  used to store dbms_output buffer captured before the run\n\n\n\n\n\nSyntax\n\n\nprocedure save_dbms_output_to_cache\n\n\n\n\nREAD_CACHE_TO_DBMS_OUTPUT Procedure\n\n\n\n\nReads data from global temporary table (cache) abd puts it back into dbms_output\n  used to recover dbms_output buffer data after a run is complete\n\n\n\n\n\nSyntax\n\n\nprocedure read_cache_to_dbms_output\n\n\n\n\nUT_OWNER Function\n\n\n\n\nFunction is used to reference to utPLSQL owned objects in dynamic sql statements executed from packages with invoker rights\n\n\n\n\n\nSyntax\n\n\nfunction ut_owner return varchar2\n\n\n\n\nParameters\n\n\n\n\n\n\n\n\nName\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nreturn\n\n\nthe name of the utPSQL schema owner\n\n\n\n\n\n\n\n\nSCALE_CARDINALITY Function\n\n\n\n\nUsed in dynamic sql select statements to maintain balance between\n  number of hard-parses and optimiser accurancy for cardinality of collections\n\n\n\n\n\nSyntax\n\n\nfunction scale_cardinality(a_cardinality natural) return natural\n\n\n\n\nParameters\n\n\n\n\n\n\n\n\nName\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nreturn\n\n\n3, for inputs of: 1-9; 33 for input of 10 - 99; 333 for (100 - 999)\n\n\n\n\n\n\n\n\nTO_XML_NUMBER_FORMAT Function\n\n\n\n\nReturns number as string. The value is represented as decimal according to XML standard:\nhttps://www.w3.org/TR/xmlschema-2/#decimal\n\n\n\n\n\nSyntax\n\n\nfunction to_xml_number_format(a_value number) return varchar2\n\n\n\n\nGET_XML_HEADER Function\n\n\n\n\nReturns xml header. If a_encoding is not null, header will include encoding attribute with provided value\n\n\n\n\n\nSyntax\n\n\nfunction get_xml_header(a_encoding varchar2) return varchar2\n\n\n\n\nTRIM_LIST_ELEMENTS Function\n\n\n\n\nIt takes a collection of type ut_varchar2_list and it trims the characters passed as arguments for every element\n\n\n\n\n\nSyntax\n\n\nfunction trim_list_elements(a_list IN ut_varchar2_list, a_regexp_to_trim in varchar2 default '[:space:]') return ut_varchar2_list\n\n\n\n\nFILTER_LIST Function\n\n\n\n\nIt takes a collection of type ut_varchar2_list and it only returns the elements which meets the regular expression\n\n\n\n\n\nSyntax\n\n\nfunction filter_list(a_list IN ut_varchar2_list, a_regexp_filter in varchar2) return ut_varchar2_list\n\n\n\n\nREPLACE_MULTILINE_COMMENTS Function\n\n\n\n\nReplaces multi-line comments in given source-code with empty lines\n\n\n\n\n\nSyntax\n\n\nfunction replace_multiline_comments(a_source clob) return clob", 
            "title": "UT_UTILS"
        }, 
        {
            "location": "/ut_utils/#ut_utils", 
            "text": "Data Types    Constants    SURROUND_WITH Function   VALIDATE_ROLLBACK_TYPE Procedure  TEST_RESULT_TO_CHAR Function  GEN_SAVEPOINT_NAME Function  STRING_TO_TABLE Function  CLOB_TO_TABLE Function  TIME_DIFF Function  INDENT_LINES Function  GET_UTPLSQL_OBJECTS_LIST Function  APPEND_TO_LIST Procedure  SET_ACTION Procedure  SET_CLIENT_INFO Procedure  TO_VERSION Function  SAVE_DBMS_OUTPUT_TO_CACHE Procedure  READ_CACHE_TO_DBMS_OUTPUT Procedure  UT_OWNER Function  SCALE_CARDINALITY Function  TO_XML_NUMBER_FORMAT Function  GET_XML_HEADER Function  TRIM_LIST_ELEMENTS Function  FILTER_LIST Function  REPLACE_MULTILINE_COMMENTS Function", 
            "title": "UT_UTILS"
        }, 
        {
            "location": "/ut_utils/#types", 
            "text": "Name  Code  Description      t_event_name  subtype t_event_name           is varchar2(30);     t_executable_type  subtype t_executable_type      is varchar2(30);     t_test_result  subtype t_test_result   is binary_integer range 0 .. 3;     t_rollback_type  subtype t_rollback_type is binary_integer range 0 .. 1;     t_version  type t_version is record(   major  natural,   minor  natural,   bugfix natural,   build  natural );     t_clob_tab  type t_clob_tab is table of clob;", 
            "title": "Types"
        }, 
        {
            "location": "/ut_utils/#constants", 
            "text": "Name  Code  Description      gc_version  gc_version                 constant varchar2(50) := 'v3.1.2.2053-develop';", 
            "title": "Constants"
        }, 
        {
            "location": "/ut_utils/#surround_with-function", 
            "text": "utPLSQL - Version 3   Copyright 2016 - 2017 utPLSQL Project   Licensed under the Apache License, Version 2.0 (the  License ):   you may not use this file except in compliance with the License.   You may obtain a copy of the License at   http://www.apache.org/licenses/LICENSE-2.0   Unless required by applicable law or agreed to in writing, software   distributed under the License is distributed on an  AS IS  BASIS,   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   See the License for the specific language governing permissions and   limitations under the License.", 
            "title": "SURROUND_WITH Function"
        }, 
        {
            "location": "/ut_utils/#syntax", 
            "text": "function surround_with(a_value varchar2, a_quote_char varchar2) return varchar2", 
            "title": "Syntax"
        }, 
        {
            "location": "/ut_utils/#validate_rollback_type-procedure", 
            "text": "Procedure: validate_rollback_type    Validates passed value against supported rollback types", 
            "title": "VALIDATE_ROLLBACK_TYPE Procedure"
        }, 
        {
            "location": "/ut_utils/#syntax_1", 
            "text": "procedure validate_rollback_type(a_rollback_type number)", 
            "title": "Syntax"
        }, 
        {
            "location": "/ut_utils/#test_result_to_char-function", 
            "text": "Converts test results into strings", 
            "title": "TEST_RESULT_TO_CHAR Function"
        }, 
        {
            "location": "/ut_utils/#syntax_2", 
            "text": "function test_result_to_char(a_test_result integer) return varchar2", 
            "title": "Syntax"
        }, 
        {
            "location": "/ut_utils/#parameters", 
            "text": "Name  Description      a_test_result  numeric representation of test result    return  a string representation of a test_result.", 
            "title": "Parameters"
        }, 
        {
            "location": "/ut_utils/#gen_savepoint_name-function", 
            "text": "Generates a unique name for a savepoint Uses sys_guid, as timestamp gives only miliseconds on Windows and is not unique Issue: #506 for details on the implementation approach", 
            "title": "GEN_SAVEPOINT_NAME Function"
        }, 
        {
            "location": "/ut_utils/#syntax_3", 
            "text": "function gen_savepoint_name return varchar2", 
            "title": "Syntax"
        }, 
        {
            "location": "/ut_utils/#string_to_table-function", 
            "text": "Splits a given string into table of string by delimiter. The delimiter gets removed. If null passed as any of the parameters, empty table is returned. If no occurence of a_delimiter found in a_text then text is returned as a single row of the table. If no text between delimiters found then an empty row is returned, example:   string_to_table(  a,,b ,  ,  ) gives table ut_varchar2_list(  a , null,  b  );", 
            "title": "STRING_TO_TABLE Function"
        }, 
        {
            "location": "/ut_utils/#syntax_4", 
            "text": "function string_to_table(a_string varchar2, a_delimiter varchar2:= chr(10), a_skip_leading_delimiter varchar2 := 'N') return ut_varchar2_list", 
            "title": "Syntax"
        }, 
        {
            "location": "/ut_utils/#parameters_1", 
            "text": "Name  Description      a_string  the text to be split.    a_delimiter  the delimiter character or string    a_skip_leading_delimiter  determines if the leading delimiter should be ignored, used by clob_to_table    return  table of varchar2 values", 
            "title": "Parameters"
        }, 
        {
            "location": "/ut_utils/#clob_to_table-function", 
            "text": "Splits a given string into table of string by delimiter. Default value of a_max_amount is 8191 because of code can contains multibyte character. The delimiter gets removed. If null passed as any of the parameters, empty table is returned. If split text is longer than a_max_amount it gets split into pieces of a_max_amount. If no text between delimiters found then an empty row is returned, example:   string_to_table(  a,,b ,  ,  ) gives table ut_varchar2_list(  a , null,  b  );", 
            "title": "CLOB_TO_TABLE Function"
        }, 
        {
            "location": "/ut_utils/#syntax_5", 
            "text": "function clob_to_table(a_clob clob, a_max_amount integer := 8191, a_delimiter varchar2:= chr(10)) return ut_varchar2_list", 
            "title": "Syntax"
        }, 
        {
            "location": "/ut_utils/#parameters_2", 
            "text": "Name  Description      a_clob  the text to be split.    a_delimiter  the delimiter character or string (default chr(10) )    a_max_amount  the maximum length of returned string (default 8191)    return  table of varchar2 values", 
            "title": "Parameters"
        }, 
        {
            "location": "/ut_utils/#time_diff-function", 
            "text": "Returns time difference in seconds (with miliseconds) between given timestamps", 
            "title": "TIME_DIFF Function"
        }, 
        {
            "location": "/ut_utils/#syntax_6", 
            "text": "function time_diff(a_start_time timestamp with time zone, a_end_time timestamp with time zone) return number", 
            "title": "Syntax"
        }, 
        {
            "location": "/ut_utils/#indent_lines-function", 
            "text": "Returns a text indented with spaces except the first line.", 
            "title": "INDENT_LINES Function"
        }, 
        {
            "location": "/ut_utils/#syntax_7", 
            "text": "function indent_lines(a_text varchar2, a_indent_size integer := 4, a_include_first_line boolean := false) return varchar2", 
            "title": "Syntax"
        }, 
        {
            "location": "/ut_utils/#get_utplsql_objects_list-function", 
            "text": "Returns a list of object that are part of utPLSQL framework", 
            "title": "GET_UTPLSQL_OBJECTS_LIST Function"
        }, 
        {
            "location": "/ut_utils/#syntax_8", 
            "text": "function get_utplsql_objects_list return ut_object_names", 
            "title": "Syntax"
        }, 
        {
            "location": "/ut_utils/#append_to_list-procedure", 
            "text": "Append a item to the end of ut_varchar2_list", 
            "title": "APPEND_TO_LIST Procedure"
        }, 
        {
            "location": "/ut_utils/#syntax_9", 
            "text": "procedure append_to_list(a_list in out nocopy ut_varchar2_list, a_item varchar2)", 
            "title": "Syntax"
        }, 
        {
            "location": "/ut_utils/#set_action-procedure", 
            "text": "Set session s action and module using dbms_application_info", 
            "title": "SET_ACTION Procedure"
        }, 
        {
            "location": "/ut_utils/#syntax_10", 
            "text": "procedure set_action(a_text in varchar2)", 
            "title": "Syntax"
        }, 
        {
            "location": "/ut_utils/#set_client_info-procedure", 
            "text": "Set session s client info using dbms_application_info", 
            "title": "SET_CLIENT_INFO Procedure"
        }, 
        {
            "location": "/ut_utils/#syntax_11", 
            "text": "procedure set_client_info(a_text in varchar2)", 
            "title": "Syntax"
        }, 
        {
            "location": "/ut_utils/#to_version-function", 
            "text": "Converts version string into version record", 
            "title": "TO_VERSION Function"
        }, 
        {
            "location": "/ut_utils/#syntax_12", 
            "text": "function to_version(a_version_no varchar2) return t_version", 
            "title": "Syntax"
        }, 
        {
            "location": "/ut_utils/#parameters_3", 
            "text": "Name  Description      a_version_no  string representation of version in format vX.X.X.X where X is a positive integer    return  t_version    record with up to four positive numbers containing version", 
            "title": "Parameters"
        }, 
        {
            "location": "/ut_utils/#thrown-exceptions", 
            "text": "throws  20214 if passed version string is not matching version pattern", 
            "title": "Thrown exceptions"
        }, 
        {
            "location": "/ut_utils/#save_dbms_output_to_cache-procedure", 
            "text": "Saves data from dbms_output buffer into a global temporary table (cache)   used to store dbms_output buffer captured before the run", 
            "title": "SAVE_DBMS_OUTPUT_TO_CACHE Procedure"
        }, 
        {
            "location": "/ut_utils/#syntax_13", 
            "text": "procedure save_dbms_output_to_cache", 
            "title": "Syntax"
        }, 
        {
            "location": "/ut_utils/#read_cache_to_dbms_output-procedure", 
            "text": "Reads data from global temporary table (cache) abd puts it back into dbms_output   used to recover dbms_output buffer data after a run is complete", 
            "title": "READ_CACHE_TO_DBMS_OUTPUT Procedure"
        }, 
        {
            "location": "/ut_utils/#syntax_14", 
            "text": "procedure read_cache_to_dbms_output", 
            "title": "Syntax"
        }, 
        {
            "location": "/ut_utils/#ut_owner-function", 
            "text": "Function is used to reference to utPLSQL owned objects in dynamic sql statements executed from packages with invoker rights", 
            "title": "UT_OWNER Function"
        }, 
        {
            "location": "/ut_utils/#syntax_15", 
            "text": "function ut_owner return varchar2", 
            "title": "Syntax"
        }, 
        {
            "location": "/ut_utils/#parameters_4", 
            "text": "Name  Description      return  the name of the utPSQL schema owner", 
            "title": "Parameters"
        }, 
        {
            "location": "/ut_utils/#scale_cardinality-function", 
            "text": "Used in dynamic sql select statements to maintain balance between   number of hard-parses and optimiser accurancy for cardinality of collections", 
            "title": "SCALE_CARDINALITY Function"
        }, 
        {
            "location": "/ut_utils/#syntax_16", 
            "text": "function scale_cardinality(a_cardinality natural) return natural", 
            "title": "Syntax"
        }, 
        {
            "location": "/ut_utils/#parameters_5", 
            "text": "Name  Description      return  3, for inputs of: 1-9; 33 for input of 10 - 99; 333 for (100 - 999)", 
            "title": "Parameters"
        }, 
        {
            "location": "/ut_utils/#to_xml_number_format-function", 
            "text": "Returns number as string. The value is represented as decimal according to XML standard: https://www.w3.org/TR/xmlschema-2/#decimal", 
            "title": "TO_XML_NUMBER_FORMAT Function"
        }, 
        {
            "location": "/ut_utils/#syntax_17", 
            "text": "function to_xml_number_format(a_value number) return varchar2", 
            "title": "Syntax"
        }, 
        {
            "location": "/ut_utils/#get_xml_header-function", 
            "text": "Returns xml header. If a_encoding is not null, header will include encoding attribute with provided value", 
            "title": "GET_XML_HEADER Function"
        }, 
        {
            "location": "/ut_utils/#syntax_18", 
            "text": "function get_xml_header(a_encoding varchar2) return varchar2", 
            "title": "Syntax"
        }, 
        {
            "location": "/ut_utils/#trim_list_elements-function", 
            "text": "It takes a collection of type ut_varchar2_list and it trims the characters passed as arguments for every element", 
            "title": "TRIM_LIST_ELEMENTS Function"
        }, 
        {
            "location": "/ut_utils/#syntax_19", 
            "text": "function trim_list_elements(a_list IN ut_varchar2_list, a_regexp_to_trim in varchar2 default '[:space:]') return ut_varchar2_list", 
            "title": "Syntax"
        }, 
        {
            "location": "/ut_utils/#filter_list-function", 
            "text": "It takes a collection of type ut_varchar2_list and it only returns the elements which meets the regular expression", 
            "title": "FILTER_LIST Function"
        }, 
        {
            "location": "/ut_utils/#syntax_20", 
            "text": "function filter_list(a_list IN ut_varchar2_list, a_regexp_filter in varchar2) return ut_varchar2_list", 
            "title": "Syntax"
        }, 
        {
            "location": "/ut_utils/#replace_multiline_comments-function", 
            "text": "Replaces multi-line comments in given source-code with empty lines", 
            "title": "REPLACE_MULTILINE_COMMENTS Function"
        }, 
        {
            "location": "/ut_utils/#syntax_21", 
            "text": "function replace_multiline_comments(a_source clob) return clob", 
            "title": "Syntax"
        }
    ]
}